Support No : 0008001007534 -> oracle support
---------------oracle home backup-------------
tar –cvf /(destination_path)/ora_version.tar 
---------------------------
############################

Repeated IPC Send timeout detected Messages With Receiver Process PPA7 (Doc ID 2219281.1)


Memory usage /ram usage 
ps aux | head -1; ps aux | grep ^oracle| sort -rnk 4 | more


0.1 ASM TO LOCAL PARTITION COPY######################################

for i in $(asmcmd ls +RECO_EXD1/CARDB/ARCHIVELOG/2018_02_15); do
  asmcmd cp +RECO_EXD1/CARDB/ARCHIVELOG/2018_02_15/$i /Vol_temp_IMPS_exadatbckp/IDCMSDB/
done
-----------------------------------TFA---------------
./tfactl diagcollect -all -from "Feb/23/2019 00:00:00" -to "Feb/23/2019 06:29:00"

./tfactl diagcollect -from "MMM/dd/yyyy hh:mm:ss" -to "MMM/dd/yyyy hh:mm:ss" -noclassify   ==> Does not ask for any prompt

tfactl directory add <path_to_database_logs-location> -public -node all 
To check locations that TFA collects: 
tfactl print directories -node all 

28/07/2020 22:42

Database Wallete ====
select * from v$encryption_wallet;

1.Kill Session  ########################################
		select 'ALTER SYSTEM KILL SESSION '||''''||sid||','||serial#||''''||' immediate;'from v$session where status='INACTIVE' and username in ('&name');
		,'CCARDSLIVE','ASTREAMSLIVE','ECHECKLISTLIVE','LASLIVE','ICHEQUELIVE','ICICIOMS','DMALIVE');
		select 'ALTER SYSTEM KILL SESSION '||''''||sid||','||serial#||',@'||inst_id||''''||' immediate;'from gv$session where status='INACTIVE' and username='&Username';
		select sid,username,logon_time,status from v$session where status='INACTIVE' and to_char(logon_time,'dd-mon-yyyy hh24:mi')<'01-aug-2015 00:00';
		select 'Alter system kill session '||''''||sid||','||serial#||''''||' immediate;' from v$session where username in ('IPSLIVE') and status='INACTIVE' and to_char(logon_time,'dd-mon-yyyy hh24:mi')<'01-JULY-2015 00:00:00';
		Select sid,username,to_char(logon_time,'dd-mon-yyyy hh24:mi'),status from v$session where status='ACTIVE';
	
2.Alert log for given time ##################################
		cat alert_FINNCOLL.log | grep -n 'Feb 10' | pg
		sed -n 179779,182573p alert_FINNCOLL.log > alert_FINNCOLL_feb10.log 
		find . -name "SSOSHAN*.aud" -print0 | xargs -0 rm
		
3.Archive deletion using RMAN ################################
		cd $ORACLE_HOME/RMAN/scripts/log
		rman target / catalog rman/rman_2005@rmancat
		
		DELETE NOPROMPT ARCHIVELOG ALL BACKED UP 2 TIMES TO 'SBT_TAPE' COMPLETED BEFORE 'SYSDATE -2';
		
		DELETE NOPROMPT ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -180';
		DELETE NOPROMPT ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -30';
		DELETE NOPROMPT ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -1/24';
		DELETE NOPROMPT force ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -0.5';
		DELETE NOPROMPT ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -7';
		
		crosscheck archivelog all;
		
			
		
		DELETE NOPROMPT ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -2';
		DELETE NOPROMPT ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -1.2';
		DELETE NOPROMPT ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -4';
		DELETE NOPROMPT ARCHIVELOG ALL  COMPLETED BEFORE 'SYSDATE -0.9';
		DELETE NOPROMPT ARCHIVELOG  UNTIL SEQUENCE 178050 THREAD  2;
		list ARCHIVELOG ALL BACKED UP 2 TIMES TO 'SBT_TAPE' COMPLETED BEFORE 'SYSDATE -2';

		delete expired archivelog all;
		crosscheck archivelog all;
		select thread#,max(sequence#) from v$archived_log where to_char(NEXT_TIME,'dd-mon-yyyy hh24:mi')<'15-feb-2020 19:00' group by thread#;
		
		rman target / nocatalog cmdfile="archdel.cmd"
		By Manual
		ls -lrt *.dbf |grep "Mar 31"|awk '{print $9}'|xargs rm -rf
		ls -lrt *tr* |grep "Jun"|awk '{print $9}'|xargs rm -rf
		
		#########Release Archive #######
		
RUN
{
ALLOCATE CHANNEL ch01 TYPE DISK ;
ALLOCATE CHANNEL ch02 TYPE DISK ;
ALLOCATE CHANNEL ch03 TYPE DISK ;
ALLOCATE CHANNEL ch04 TYPE DISK ;
ALLOCATE CHANNEL ch05 TYPE DISK ;
ALLOCATE CHANNEL ch06 TYPE DISK ;
DELETE NOPROMPT ARCHIVELOG ALL BACKED UP 2 TIMES TO 'SBT_TAPE' COMPLETED BEFORE 'SYSDATE -2';
RELEASE CHANNEL ch01;
RELEASE CHANNEL ch02;
RELEASE CHANNEL ch03;
RELEASE CHANNEL ch04;
RELEASE CHANNEL ch05;
RELEASE CHANNEL ch06;
}

		
4.LISTERNER STOP START :
		ps -ef|grep tns|awk '{print "lsnrctl start " $10}'
		ps -ef|grep tns|awk '{print "lsnrctl stop " $10}'
		ps -ef|grep ora9i| grep exp|awk '{print $10}'|xargs -t -I {} lsnrctl stat {}
		
5.Clear Dump Dest
		ls -lrt *aud*|grep "Oct 24"|awk '{print $9}'
		ls -lrt *out|grep "Feb"|awk '{print $9}'|xargs nohup compress &
		ls -lrt *.arc|grep "Feb  4"|awk '{print $9}'|xargs nohup compress &
		ls -lrt *.tr*|grep "Jun 14"|awk '{print $9}'|xargs nohup compress &
		ls -lrt *tr*|grep "May 16"|awk '{print $9}'|xargs nohup gzip &
		ls -lrt *.arc|grep "Nov 20"|awk '{print "mv "$9}'
		ls -lrt *core*|grep "Feb  6"|awk '{print $9}'|xargs rm -rf
		
		ls -lrt |grep "Dec"|awk '{print $9}'|xargs rm -rf
		ls -lrt *core*|grep "Jun  4"|awk '{print $9}'|xargs rm -rf
		ls -lrt |grep "Apr  9"|grep arc|awk '{print $9}'|xargs rm
		ls -lrt *.ar*|grep "Aug"|awk '{print $9}'|xargs rm
		ls -lrt *.tr*|grep "Nov  5"|awk '{print $9}'|xargs rm
		
		find . -name "*arc*" -mtime +15 -exec rm -rf  {} \;
		find . -name "*aud*" -mtime +7 -exec rm -rf   {} \;
		find . -name "*log*" -mtime +7 -exec rm -rf   {} \;
		find . -name "*.tr*" -mtime +15 -exec rm  {} \;
	
6.Clear OEM
		/oem10g/oracle/agent_12C/agent_inst/sysman/emd
		/oem12c/oracle/agent12c/agent_inst/sysman/emd
		/oem10g/oracle/agent12c/agent_inst/sysman/log
		
		 find . -name '*.gz*' -mtime +90 -exec rm {} \;
		 find . -name '*.tr*' -mtime +3 -exec rm {} \;
		 /usr/bin/find /oem10g/oracle -name heap* -exec /bin/rm -f {} \; 

		
7.Duplicate Datafiles
		select file_name from dba_data_files where tablespace_name='&talespacename' and file_name like '%&maxfileno%';
		For Unixs
		select substr(name,instr(name,'/',-1)+1,60) name from v$datafile where lower(substr(name,instr(lower(name),'/',-1)+1,60)) = lower('&1');
		
		Windows....
		select substr(name,instr(name,'\',-1)+1,60) name from v$datafile where lower(substr(name,instr(lower(name),'\',-1)+1,60)) = lower('&1');
		
		set lines 132
		set pages 1000
		column duplicate_datafiles for a40
		select substr(name,instr(name,'/',-1)+1) Duplicate_datafiles, count(*)
		from v$datafile
		group by substr(name,instr(name,'/',-1)+1)
		having count(*)>1
		/
		
		select name nm,creation_time from v$datafile
		where substr(name,instr(name,'/',-1,1)+1) in 
		(select substr(file_name,instr(file_name,'/',-1,1)+1) from dba_data_files
		group by substr(file_name,instr(file_name,'/',-1,1)+1) 
		having count(*)> 1)
		/
8.Rename Datafile#########################################
		select 'alter database rename file '||file#||' to '||name from v$datafile
		select 'alter database rename file '||name||''''||' to '||''''||name||''''||';' from v$datafile;

REcover database checkpoint 
select * from v$recover_file where error like ‘%FILE%’;
 select distinct fuzzy,checkpoint_change# from v$datafile_header ;

FUZ CHECKPOINT_CHANGE#
--- ------------------
NO          1.5601E+13


9.Find max process query *****************************************************************

		col MACHINE for a15
		col username for a10
		col SQL_TEXT for a75
		set lines 1000 pages 100
		select count(*),username,machine,sql_text from
		(select sess.sid,
				sess.serial#,
				sess.username,sess.machine,sql_text
		 from v$sqlarea sqlarea, v$session sess
		 where sess.prev_hash_value = sqlarea.hash_value
		 and sess.prev_sql_addr = sqlarea.address
		 and sess.status='INACTIVE') a group by username,machine,sql_text
		 having count(*)>1
		 order by 1 desc; 
 
10.Trace ENAble  ==========

		SELECT p.tracefile
		FROM   v$session s
			   JOIN v$process p ON s.paddr = p.addr
		WHERE  s.sid = 635;
		
		
select spid from v$process where addr = (select paddr from v$session where sid=&SID);
oradebug SETOSPID 19664
oradebug UNLIMIT
oradebug EVENT 10046 trace name context forever,level 12;
oradebug TRACEFILE_NAME

oradebug SETOSPID 4456862
oradebug EVENT 10046 trace name context off;  To close Trace
oradebug CLOSE_TRACE; To close Trace

TKPROF TRACE_FILE.trc O/P.txt sys=NO
TKPROF PCMSPRD_ora_5963826.trc PCMSPRD_ora_18FEB20.txt sys=NO

11.Parallel session query **************************
		select * from v$px_session;

12.************** RMAN RESTORATION*************
		nohup rman target / catalog rman/rman_2005@rmancat cmdfile="dm.cmd" log="dm.out" & 

		

		oracle@issc02dbadm01:/test1/Full_RMAN_16APR14$ cat restoredb.sh
		export ORACLE_SID=FINNONE1
		export ORACLE_HOME=/u01/app/oracle/product/11.2.0.3/dbhome_1
		/u01/app/oracle/product/11.2.0.3/dbhome_1/bin/rman target / << EOF
		spool log to /test1/Full_RMAN_16APR14/finn_prod_restore_18Apr2014.log
		run {
		set newname for database to '+DATA_ISSC';
		restore database;
		switch datafile all;
		recover database;
		
		}
		exit
		spool log off
		EOF
==========================================================
		RMAN > RESTORE DATABASE PREVIEW;
		RMAN > RESTORE DATAFILE 3 PREVIEW;
		
		RMAN > STARTUP FORCE MOUNT;
        RMAN > RESTORE CONTROLFILE;  # restore control file from consistent backup
        RMAN > ALTER DATABASE MOUNT;
        RMAN > RESTORE DATABASE;  # restore datafiles from consistent backup
        RMAN > Switch database to copy ;  # restore datafiles from consistent backup
        RMAN > RECOVER DATABASE NOREDO;  # specify NOREDO because online redo logs are lost
        RMAN > ALTER DATABASE OPEN RESETLOGS;
		
		
13.*********************************Junk *********************************************
		col name for a80
		set lines 120
		set pages 5000
		select file#, name, trunc(creation_time), bytes/1024/1024 "SIZE" from v$datafile where
		length(translate(upper(name),'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./\_:','$'))<>0
		order by 3;
		
14.############################### To KILL FINN PROCESSES ###############################

		ps -ef | grep "LOCAL=NO"|grep oracleCPSUAT|awk '{print $2}'|xargs -t -I {} kill -9 {}

		ps -ef | grep "LOCAL=NO"|grep FCRMPROD|awk '{print $2}'|xargs -t -I {} kill -9 {}
		
15.############################### Kill OS level Oracle Process ###############################
		ps -ef|grep oracleFINN |grep "LOCAL=NO" |awk '{print $2}'|xargs kill -9
		ps -ef|grep oracleOMS |grep "LOCAL=NO" |awk '{print $2}'|xargs kill -9
		
16.############### undostat ####################

		select distinct MAXQUERYID,MAXQUERYLEN from v$undostat where MAXQUERYLEN>5000 order by MAXQUERYLEN;
		select distinct MAXQUERYID from v$undostat where MAXQUERYLEN<6718;
		select sql_text from dba_hist_sqltext where SQL_ID='8xhjuvc7ghym1';
		
17.######################kill session before 1hrs##################
		select 'Alter system kill session '||''''||sid||','||serial#||''''||' immediate ;' 
		from v$session where status='INACTIVE' and username='BAH';
		where sid in (select sid
				from v$session
				where status='INACTIVE'
				and to_char(logon_time,'dd-mon-yyyy hh24:mi')<'01-JUN-2010 15:00:00'
				and username='SGMADM');

		select 'Alter system kill session '||''''||sid||','||serial#||''''||'immediate ;' 
		from v$session
		where sid in (select sid
		from v$session  where  type='USER'
		and username in ('CUST_DEDUPE','DC_OWNER') and status='ACTIVE'
		);


		select 'Alter system kill session '||''''||sid||','||serial#||''''||' immediate ;' 
		from v$session
		where sid in (select sid
				  from v$session
				  where event in ('db file sequential read','read by other session')
				  and machine='sf1280-01');

		select 'Alter system kill session '||''''||sid||','||serial#||''''||' immediate;' 
		from v$session where username in ('IPSLIVE','IPSH2H','WEBLOGIC','SRILANKAIPS') and status='INACTIVE' and to_char(logon_time,'dd-mon-yyyy hh24:mi')<'24-JUN-2015 00:00:00';

		select 'create or replace PUBLIC SYNONYM''"'||object_name||'"''for SYS'||'.'||'"'||object_name||'"' from dba_objects where status<>'VALID'

		******************** To kill All locked inactive sessions ***************

		select OWNER, OBJECT_NAME, SID, SERIAL#,a.logon_time,a.status, locked_mode
		from v$session a, v$locked_object b, dba_objects c
		where a.SID=b.session_id
		and b.OBJECT_ID=c.OBJECT_ID
		and a.status='INACTIVE'
		and b.ORACLE_USERNAME='IBSLSFA'
		order by 5;
		
		==================================Telnet============
		
		netstat -an | grep 1521|grep target ip
		
		======================================================
18.********************* reverse scp *********************
		scp ora1201@172.16.13.52:/cmsweblidata8/IPSLIVE_TABLES_EXPDUMP/CMSWEB09MAY2015_NEW.dmp.gz /tmp
19.RMAN Backup Status.***********************************************
		This script will report on all RMAN backups like full, incremental & archivelog backups:
		
		col STATUS format a25
		col hrs format 999.99
		set lines 300
		
		select SESSION_KEY, INPUT_TYPE, STATUS,
		to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
		to_char(END_TIME,'mm/dd/yy hh24:mi') end_time,
		elapsed_seconds/3600 hrs
		from V$RMAN_BACKUP_JOB_DETAILS
		order by session_key; 
		
		
		col hrs format 999.99
		set lines 300
		
		select SESSION_KEY, INPUT_TYPE, STATUS,
		to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
		to_char(END_TIME,'mm/dd/yy hh24:mi') end_time,
		elapsed_seconds/3600 hrs,INPUT_BYTES/1024/1024/1024,OUTPUT_BYTES/1024/1024/1024
		from V$RMAN_BACKUP_JOB_DETAILS
		order by session_key; 
		
20. DR Lag ###############################

		select arch.thread# "Thread",arch.sequence# "Last Sequence Received", APPL.sequence# "Last Sequence Applied",
		(arch.sequence#-APPL.sequence#) "difference" from (select thread#,sequence# from v$archived_log where (thread#,First_time) in (select thread#,max(First_time) from v$archived_log group by thread#)) arch,
		(select thread#,sequence# from v$log_history where (thread#,First_time) in (select thread#,max(First_time) from v$log_history group by thread#)) Appl where arch.thread#=appl.thread# order by 1;
	
	
		select 'Last applied  : ' Logs, to_char(next_time,'DD-MON-YY:HH24:MI:SS') Time
			   from v$archived_log
			  where sequence# = (select max(sequence#) from v$archived_log where applied='YES')    union
			  select 'Last received : ' Logs, to_char(next_time,'DD-MON-YY:HH24:MI:SS
		') Time    from v$archived_log    where sequence# = (select max(sequence#) from v$archived_log);

21.************************** DB SIZE ******************************
		set lines 200
		set pagesize 50000
		tti "Database growth per month for last year"

		select to_char(creation_time, 'RRRR Month') "Month",
			   sum(bytes)/1024/1024 "Growth in Meg"
		from sys.v$datafile
		--where creation_time > SYSDATE
		group by to_char(creation_time, 'RRRR Month')
		order by 1;

		select sum(a.BYTES/1024/1024/1024) "Database Size GB",
			sum(b.BYTES/1024/1024/1024) "Database Free Size GB",
			sum(c.BYTES/1024/1024/1024) "Database Used Size GB"
		from sm$ts_avail a, sm$ts_free b, sm$ts_used c
		where a.TABLESPACE_NAME=b.TABLESPACE_NAME
		and a.TABLESPACE_NAME=c.TABLESPACE_NAME;
============================== datafile free space ==============================
select df.tablespace_name, df.file_name, round(df.bytes/1024/1024) totalSizeMB, nvl(round(usedBytes/1024/1024), 0) usedMB, nvl(round(freeBytes/1024/1024), 0) freeMB,
    nvl(round(freeBytes/df.bytes * 100), 0) freePerc, df.autoextensible
from dba_data_files df
    left join (
        select file_id, sum(bytes) usedBytes
        from dba_extents
        group by file_id
    ) ext on df.file_id = ext.file_id
    left join (
        select file_id, sum(bytes) freeBytes
        from dba_free_space
        group by file_id
    ) free on df.file_id = free.file_id
order by df.tablespace_name, df.file_name;

==================resize datafiles ===
select 'alter database datafile '||''''||b.file_name||''''||' resize '||round(((c.max_blockid+a.blocks) *8192)/1024/1024 + 10) ||'M ;' 
from dba_extents a, dba_data_files b ,
(select file_id, max(block_id) max_blockid from dba_extents group by file_id) c
where a.file_id=b.file_id and a.file_id=c.file_id and a.block_id = c.max_blockid
and b.TABLESPACE_NAME='&ts';
		
22.************************* Tablespace growth ****************************

		select  t.TARGET_NAME,m.METRIC_NAME,v.KEY_VALUE,to_number(nvl(v.VALUE,'0'))
		  value,v.COLLECTION_TIMESTAMP,
					  CASE
						WHEN m.is_transposed = 0 THEN
						   m.column_label
						ELSE
						   key_value
						END column_label
		  from
		  mgmt_targets t,
		  mgmt_metrics m,
		  mgmt_metrics_raw v
		  where t.TARGET_GUID=v.TARGET_GUID
		  AND m.metric_guid = v.METRIC_GUID
		  --AND m.type_meta_ver = t.type_meta_ver
		  and m.metric_name in ('problemTbsp')
		  and t.TARGET_NAME='MXG'
		  and v.KEY_VALUE='DATA'
		  and v.METRIC_GUID='1F9B062F8B273CD8819C5D80CA96E323'
		  order by v.COLLECTION_TIMESTAMP

		select 
		   to_char (sp.begin_interval_time,'dd-mm-yyyy') days, 
			ts.tsname,
		   max(round((tsu.tablespace_size* dt.block_size )/(1024*1024),2) ) cur_size_mb,
		   max(round((tsu.tablespace_usedsize* dt.block_size )/(1024*1024),2)) usedsize_mb, 
		from 
		   dba_hist_tbspc_space_usage tsu,
		   dba_hist_tablespace_stat ts,
		   dba_hist_snapshot sp,
		   dba_tablespaces dt
		where 
		   tsu.tablespace_id= ts.ts#
		and 
		   tsu.snap_id = sp.snap_id
		and 
		   ts.tsname = dt.tablespace_name
		and 
		   ts.tsname not in ('SYSAUX','SYSTEM')
		group by 
		   to_char (sp.begin_interval_time,'dd-mm-yyyy'), ts.tsname 
		order by ts.tsname, days;	select  t.TARGET_NAME,m.METRIC_NAME,v.KEY_VALUE,to_number(nvl(v.VALUE,'0'))
		  value,v.COLLECTION_TIMESTAMP,
					  CASE
						WHEN m.is_transposed = 0 THEN
						   m.column_label
						ELSE
						   key_value
						END column_label
		  from
		  mgmt_targets t,
		  mgmt_metrics m,
		  mgmt_metrics_raw v
		  where t.TARGET_GUID=v.TARGET_GUID
		  AND m.metric_guid = v.METRIC_GUID
		  --AND m.type_meta_ver = t.type_meta_ver
		  and m.metric_name in ('problemTbsp')
		  and t.TARGET_NAME='MXG'
		  and v.KEY_VALUE='DATA'
		  and v.METRIC_GUID='1F9B062F8B273CD8819C5D80CA96E323'
		  order by v.COLLECTION_TIMESTAMP

		select 
		   to_char (sp.begin_interval_time,'dd-mm-yyyy') days, 
			ts.tsname,
		   max(round((tsu.tablespace_size* dt.block_size )/(1024*1024),2) ) cur_size_mb,
		   max(round((tsu.tablespace_usedsize* dt.block_size )/(1024*1024),2)) usedsize_mb, 
		from 
		   dba_hist_tbspc_space_usage tsu,
		   dba_hist_tablespace_stat ts,
		   dba_hist_snapshot sp,
		   dba_tablespaces dt
		where 
		   tsu.tablespace_id= ts.ts#
		and 
		   tsu.snap_id = sp.snap_id
		and 
		   ts.tsname = dt.tablespace_name
		and 
		   ts.tsname not in ('SYSAUX','SYSTEM')
		group by 
		   to_char (sp.begin_interval_time,'dd-mm-yyyy'), ts.tsname 
		order by ts.tsname, days;

23.************************* create user	 ****************************
		APPLICATION USER
		-----------------
		set lines 150
		set pages 2500
		col username for a30
		col default_tablespace for a30
		col temporary_tablespace for a30
		col profile for a30
		select username,account_status,default_tablespace, temporary_tablespace, profile,CREATED
		from dba_users where username='&username' ;

		create user SCSSLIVE identified by SCSSLIVE_123 default tablespace USERS temporary tablespace LMTEMP;

		grant connect, resource, unlimited tablespace to SCSSLIVE;

		alter user SCSSLIVE profile icicibank_profile_system;

		NON APPLICATION USER
		----------------
		create user RIBQUERY identified by RIB_QUERY321
		default tablespace CORP_CUST
		temporary tablespace LMTEMP;

		grant ICICI_CONNECT to RIBQUERY;

		alter user RIBQUERY profile icicibank_profile;

		grant create session to ICICI_CONNECT;
		create role ICICI_CONNECT;

24.************************** spid from sid ***************************
		 set lines 123
		 col USERNAME for a15
		 col OSUSER for a8
		 col MACHINE for a15
		 col PROGRAM for a20
		 select b.spid, a.username, a.program , a.osuser ,a.machine,  a.sid, a.serial#, a.status from v$session a, v$process b
		 where addr=paddr(+) and sid=&sid
  
25.************************** sid from spid *******************************

		 set lines 150
		 set pages 500
		 col USERNAME for a15
		 col OSUSER for a8
		 col MACHINE for a15
		 col PROGRAM for a20
		 select  a.username, a.program , a.osuser ,a.machine,  a.sid, a.serial#, a.status from v$session a, v$process b  where a.paddr=b.addr and b.spid=&spid ;
		 
		 *****************KILL HOLDER **********************************************************
		 select 'ALTER SYSTEM KILL SESSION '||''''||sid||','||serial#||''''||' immediate;'from 
		 ( select distinct BLOCKER_SID sid, BLOCKER_SESS_SERIAL# serial#  from V$SESSION_BLOCKERS );
		 
26.************************ holder /waiter ****************************************

			SELECT /*+ RULE */ DECODE(request, 0,'HOLDER','WAITER'), inst_id,sid , lmode,  TYPE, ctime 
			FROM gv$lock
			WHERE (id1, id2, TYPE ) IN (SELECT id1, id2, TYPE 
										FROM gv$lock 
										WHERE request>0)
			ORDER BY id1, request;

		Waits for 'Enq: Tx - Row Lock Contention' - Wait Scenario Examples (Doc ID 62354.1)

		SELECT t.OWNER, t.OBJECT_NAME, t.OBJECT_TYPE, t.STATISTIC_NAME, t.VALUE ,i.table_name,i.INI_TRANS,i.MAX_TRANS
		FROM v$segment_statistics t ,dba_indexes i 
		WHERE t.STATISTIC_NAME = 'ITL waits' 
		AND t.VALUE > 0 
		and t.OBJECT_type='INDEX' 
		and t.owner='STIRM2I'
		and i.index_name=t.object_name
		and i.table_name='&tname';

		select dbms_metadata.get_ddl('&ttype','&tname','&owner') from dual;
		set pagesize 299
set long 999
select dbms_metadata.get_ddl('PROCOBJ','DBACLASS_PURGE','DBAUSER') from dual;


		set linesize 150
		set echo off
		col oruser format a20 heading "Oracle Username"
		col osuser format a20 heading "O/S Username"
		col obj format a30 heading "Locked Object"
		col ss heading "SID/Ser#" format a12
		col time heading "Logon Date/Time" format a19
		col unix heading "Unix|Process" format a9
		set linesize 120
		select     owner||'.'||object_name obj
		   ,oracle_username||' ('||s.status||')' oruser
		   ,os_user_name osuser
		   ,l.process unix
		   ,s.sid||','||s.serial# as ss
		   ,to_char(s.logon_time,'yyyy/mm/dd hh24:mi:ss') time
		from       v$locked_object l
		   ,dba_objects o
		   ,v$session s
		where l.object_id = o.object_id
		  and s.sid=l.session_id
		order by osuser, ss, obj;
		
27.************************get sql from sid ***************************************

		set linesize 132
		SELECT SQL_TEXT
		FROM V$SESSION, V$SQLtext
		WHERE V$SESSION.SQL_ADDRESS = V$SQLtext.ADDRESS
		AND V$SESSION.SID = &SID
		order by piece;

28.**************************get sql from spid **************************

		set linesize 132
		SELECT SQL_HASH_VALUE,SQL_TEXT
		FROM V$SESSION, V$SQLtext
		WHERE V$SESSION.SQL_ADDRESS = V$SQLtext.ADDRESS
		AND V$SESSION.SID in ( select  a.sid from v$session a, v$process b
		 where a.paddr=b.addr and b.spid=&spid )
		order by piece

29.**************************wait events--- sess_wait *****************************
		col sid format 99999
		col event format a30
		col state format a25
		col p1 format 99999999999999
		col p2 format 99999999999999
		set pages 200
		set lines 200
		break on event
		compute count of event on event
		select sid,event,p1,p2 , p3  
		from v$session_wait 
		where event not like '%message%'
		and state = 'WAITING'
		order by event;
		
		
		set lines 200 
set pages 1000
col event format a60


PROMPT --> Top 25 Wait Events for active sessions

select * from
(select event,count(*) E_COUNT from v$session
where status='ACTIVE'
group by event
order by 2 desc)
where rownum < 26;

col sid format 999999
col sql format a35
col username format a15
col osuser format a10
col child format 99
col secs format 99999
col machine format a15
col event format a25
col state format a10

select  distinct
w.sid,s.username,s.osuser,substr(w.event,1,25) event,substr(s.machine,1,12) machine,substr(w.state,1,10) state,s.SQL_ID,s.SQL_CHILD_NUMBER CHILD,
substr(q.sql_text,1,33) "SQL",round(s.LAST_CALL_ET/60) "MINS"--,q.buffer_gets
from v$session_wait w,v$session s,v$sql q where  w.sid=s.sid
and s.SQL_HASH_VALUE=q.HASH_VALUE(+)
and s.status='ACTIVE'
and s.username is not null
and substr(w.event,1,25) not like 'SQL*Net message from clie%'
order by "MINS"
/



30.****************************************** Top 5 events in Database ****************************************

		select event, total_waits,
			round(time_waited/100) "TIME(s)",
			average_wait*10 "AVG(ms)",
			TO_CHAR(SYSDATE, 'DD-MON-YYYY HH:MI:SS') time
		from v$system_event 
		where time_waited > 100 
		and event not in ('rdbms ipc message','pmon timer','control file heartbeat','smon timer')
		order by time_waited;
		
31.*************************Long Running Sessions*********************
		set lines 200 pages 300
		col target  for a40
		SELECT SID,  target || opname target , TOTALWORK, SOFAR, TIME_REMAINING, ELAPSED_SECONDS 
		FROM gV$SESSION_LONGOPS
		where time_remaining > 0
		order by time_remaining;
		
		
		By Nazeer Sir
		
		col MESSAGE for a80
		SELECT sid, serial#, message, context, sofar, totalwork, round(sofar/totalwork*100,2) "% Complete" FROM v$session_longops where SOFAR<>TOTALWORK;
		
		
		col sid form 9999
col start_time head "Start|Time" form a12 trunc
col opname head "Operation" form a12 trunc
col target head "Object" form a24 trunc
col totalwork head "Total|Work" form 999999999 trunc
col Sofar head "Sofar" form 9999999999 trunc
col elamin head "Elapsed|Time|(Mins)" form 999999 trunc
col tre head "Time|Remain|(Mins)" form 99999 trunc
select sid,rpad(username,10) username,to_char(start_time,'dd-mon:hh24:mi') start_time,
   opname,target,totalwork,sofar,(elapsed_Seconds/60/60) elamin,
   time_remaining tre
from gv$session_longops
where totalwork<>sofar
order by start_time;


		
		
		
SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,opname ,
ROUND(SOFAR/TOTALWORK*100,2) "%_COMPLETE", Time_remaining
FROM V$SESSION_LONGOPS
WHERE OPNAME LIKE 'RMAN%'
AND OPNAME NOT LIKE '%aggregate%'
AND TOTALWORK != 0
AND SOFAR != TOTALWORK; 

Below long running give details 

set echo off  linesize 200  pages 1000  head on  feedback on
 col username format a10
 col start_time format a15
 col curr_time format a15
 col osuser format a10
 col opname format a35
 col target format a25
 col tremain format 999999.99
 col elamin format 999999.99
 select a.sid,substr(b.username,1,10) username,substr(b.osuser,1,10) osuser,to_char(a.start_time,'dd-mon:hh24:mi:ss') start_time,
 to_char(sysdate,'dd-mon:hh24:mi:ss') curr_time,a.opname,a.target,a.totalwork,a.sofar,(a.elapsed_Seconds)/60 elamin,
 a.time_remaining/60 tremain
 from v$session_longops a,
 v$session b
 where a.totalwork<>a.sofar
 and a.sid=b.sid
 order by 3
 /


040- 682104068216018


		
SQL MONITOR
=====================================================================

set lines 300 long 1000000 longchunksize 10000000 pages 5000 verify off
select dbms_sqltune.report_sql_monitor('&sql_id',type=>'TEXT',report_level=>'ALL') FROM DUAL;
		
		
*********Import STAT


Export stats

exec dbms_stats.CREATE_STAT_TABLE('ORACLE','BACKUP_USTTAXTRANSACTION_STA1');
exec dbms_stats.export_table_stats(ownname=>'GENEVA_ADMIN',tabname=>'USTTAXTRANSACTION',stattab=>'BACKUP_USTTAXTRANSACTION_STA1',statown=>'ORACLE',cascade=>TRUE);

take export backup of  BACKUP_USTTAXTRANSACTION_STA1 table and import it into target

exec dbms_stats.import_table_stats (ownname=>'ORACLE',tabname=>'USTTAXTRANSACTION',stattab=>'BACKUP_USTTAXTRANSACTION_STA1');


lock table stats

DBMS_STATS.LOCK_TABLE_STATS('GENEVA_ADMIN','USTTAXTRANSACTION');
IMPORT STATS

schema 
=======
exec dbms_stats.import_schema_stats (OWNNAME=>'CSENSE',STATTAB=>'CSENSE_STATS_23MAY18',STATID=>'CSENSE_STATS_23MAY2018',STATOWN=>'SYS');

table
======== 
exec dbms_stats.import_table_stats (OWNNAME=>'&owner',TABNAME=>'&tablename',STATTAB=>'&stattable',STATID=>'&statid',STATOWN=>'SYS');
	
*******Previous SQL
select a.SNAP_ID,a.SAMPLE_TIME,a.SESSION_ID,a.SESSION_SERIAL#,a.USER_ID,a.SQL_ID,b.SQL_FULLTEXT from DBA_HIST_ACTIVE_SESS_HISTORY a, v$sql b where a.SQL_ID=b.SQL_ID 
 and  SQL_FULLTEXT like '%ICI_NM_SRCH%';
 
32.*********************who is using which UNDO or TEMP SEGMENT**************

		col SID_SERIAL for a11
		col ORAUSER for a10
		col UNDOSEG for a11
		col Undo for a5
		col PROGRAM for a30
		SELECT TO_CHAR(s.sid)||','||TO_CHAR(s.serial#) sid_serial,
		NVL(s.username, 'None') orauser,s.program,r.name undoseg,
		t.used_ublk * TO_NUMBER(x.value)/1024||'K' "Undo"
		FROM sys.v_$rollname r,sys.v_$session s,sys.v_$transaction t,sys.v_$parameter x
		WHERE s.taddr = t.addr
		AND r.usn   = t.xidusn(+)
		AND x.name  = 'db_block_size'


		col username for a10
		col SID_SERIAL for a11
		col size for a10
		col TABLESPACE for a10
		col PROGRAM for a40
		SELECT b.tablespace,
		ROUND(((b.blocks*p.value)/1024/1024),2)||'M' "SIZE",
		a.sid||','||a.serial# SID_SERIAL,
		a.username,
		a.program
		FROM sys.v_$session a,
		sys.v_$sort_usage b,
		sys.v_$parameter p
		WHERE p.name  = 'db_block_size'
		AND a.saddr = b.session_addr
		ORDER BY b.tablespace, b.blocks;


		SELECT sid, to_char(sysdate,'mi:ss') time,round(work_area_size/1048576, 1) work_area_size_mb,
			round(max_mem_used/1048576, 1) max_mem_used_mb, 
			number_passes, nvl(tempseg_size/1048576, 0) tempseg_size_mb
		FROM v$sql_workarea_active
		ORDER BY sid;

		-For values of PAT below 1 GB, _PGA_MAX_SIZE is 200 MB.
		-For values of PAT between 1 GB and 2 GB, _PGA_MAX_SIZE is 20% of PAT.
		-At values beyond 2 GB, _PGA_MAX_SIZE keeps on growing as PAT is increased, 
			but at alower rate, such that _PGA_MAX_SIZE is less than 20% of PAT.
		-A limit of 480 MB on _PGA_MAX_SIZE takes effect at a PAT value of 4 GB.
		-Increasing PAT beyond 4 GB does not result in higher values of _PGA_MAX_SIZE than 480 MB.
		-In Oracle9i, _PGA_MAX_SIZE had a limit of 200 MB.

		Process memory usage - AIX

		ps -A -o user,pid,pcpu,pmem,vsz,time,args | sort +4


		SELECT PROGRAM, PGA_USED_MEM, PGA_ALLOC_MEM/(1024*1024) "ALLOC(MB)",
		PGA_FREEABLE_MEM FREEABLE, PGA_MAX_MEM
		FROM V$PROCESS
		order by pga_alloc_mem asc;
		
		
		SET PAGESIZE 60
SET LINESIZE 300
COLUMN username FORMAT A20
COLUMN sid FORMAT 9999
COLUMN serial# FORMAT 99999

SELECT s.username,
       s.sid,
       s.serial#,
       t.used_ublk,
       t.used_urec,
       rs.segment_name,
       r.rssize,
       r.status
FROM   v$transaction t,
       v$session s,
       v$rollstat r,
       dba_rollback_segs rs
WHERE  s.saddr = t.ses_addr
AND    t.xidusn = r.usn
AND   rs.segment_id = t.xidusn
ORDER BY t.used_ublk DESC;
		
33.********************Undo usage**************************

		col program format a30
		col sid_serial format a30
		set lines 500
		SELECT TO_CHAR(s.sid)||','||TO_CHAR(s.serial#) sid_serial,
			  NVL(s.username, 'None') orauser,s.status,
			  s.program,
			  r.name undoseg,
			  t.used_ublk * TO_NUMBER(x.value)/1024/1024||'MB' "Undo"
		 FROM sys.v_$rollname    r,
			  sys.v_$session     s,
			  sys.v_$transaction t,
			  sys.v_$parameter   x
		WHERE s.taddr = t.addr
		  AND r.usn   = t.xidusn(+)
		  AND x.name  = 'db_block_size';


**************************************************UNDO EXPIRED*************************************************
		select((select (nvl(sum(bytes),0)) from dba_undo_extents where tablespace_name='&undo_name' 
		and status in ('ACTIVE','UNEXPIRED')) *100) /  (select sum(bytes)  from dba_data_files 
		where tablespace_name='&undo_name') "PCT_INUSE" from dual; 

Undo extent status examples
With the next query you go through the contents of the Undo tablespace and sum the extent types:
		select status,
		  round(sum_bytes / (1024*1024), 0) as MB,
		  round((sum_bytes / undo_size) * 100, 0) as PERC
		from
		(
		  select status, sum(bytes) sum_bytes
		  from dba_undo_extents
		  group by status
		),
		(
		  select sum(a.bytes) undo_size
		  from dba_tablespaces c
			join v$tablespace b on b.name = c.tablespace_name
			join v$datafile a on a.ts# = b.ts#
		  where c.contents = 'UNDO'
			and c.status = 'ONLINE'
		);
 
******************** Undo recover session ********************

		select    usn, state, undoblockstotal "Total", undoblocksdone "Done", undoblockstotal-undoblocksdone "ToDo",
		decode(cputime,0,'unknown',sysdate+(((undoblockstotal-undoblocksdone) / (undoblocksdone / cputime)) / 86400)) "Estimated time to complete" from gv$fast_start_transactions;

For FINN
If it is LOW set to HIGH 
		sho parameter fast_start_parallel_transaction=HIGH; For best and fastest recovery undo session;
		select a.sid, a.username, b.xidusn, b.used_urec, b.used_ublk from v$session a, v$transaction b where a.saddr=b.ses_addr;
		
		alter system set FAST_START_PARALLEL_ROLLBACK=HIGH scope=both;

		
34.************************how full is current log file***********************

		SELECT le.leseq           "Current log sequence No",
		100*cp.cpodr_bno/le.lesiz "Percent Full",
		cp.cpodr_bno              "Current Block No",
		le.lesiz                  "Size of Log in Blocks"
		FROM x$kcccp cp, x$kccle le
		WHERE le.leseq =CP.cpodr_seq
		AND bitand(le.leflg,24) = 8;
		
35.********************PARTITION Details **********************************

		select 	distinct substr(name,1,instr(name,'/',-1,1)-1) partion 
		from 	v$datafile
		union
		select 	substr(name,1,instr(name,'/',-1,1)-1) partion 
		from 	V$tempfile
		union
		select 	substr(name,1,instr(name,'/',-1,1)-1) partion 
		from 	v$controlfile
		union
		select 	substr(member,1,instr(member,'/',-1,1)-1) partion 
			from 	v$logfile;
			
36.List all privileges given to a user:======================================

		select
		  lpad(' ', 2*level) || granted_role "User, his roles and privileges"
		from
		  (
		  /* THE USERS */
			select
			  null     grantee,
			  username granted_role
			from
			  dba_users
			where
			  username like upper('%&enter_username%')
		  /* THE ROLES TO ROLES RELATIONS */
		  union
			select
			  grantee,
			  granted_role
			from
			  dba_role_privs
		  /* THE ROLES TO PRIVILEGE RELATIONS */
		  union
			select
			  grantee,
			  privilege
			from
			  dba_sys_privs
		  )
		start with grantee is null
		connect by grantee = prior granted_role; 
		====================
DBA_ROLE_PRIVS - Roles granted to users and roles
ROLE_ROLE_PRIVS - Roles which are granted to roles
ROLE_SYS_PRIVS - System privileges granted to roles
ROLE_TAB_PRIVS - Table privileges granted to roles

break on grantee skip 1
select
    grantee,
    granted_role,
    admin_option,
    default_role
from
    dba_role_privs
order by
    1,2
/

Since the request was for same access as user='GMS_DIKO1216', you can just assign to his userid whatever is missing from here:  
SYS@cgrbprd:PRODUCTION>select * from dba_role_privs where grantee='GMS_DIKO1216';

GRANTEE                        GRANTED_ROLE                   ADM DEL DEF COM
------------------------------ ------------------------------ --- --- --- ---
GMS_DIKO1216                   AMS_ROLE                       NO  NO  YES NO
GMS_DIKO1216                   RBM_REPORTS_RO_ROLE            NO  NO  YES NO
GMS_DIKO1216                   GENEVAAPP                      YES NO  YES NO
GMS_DIKO1216                   GENEVASECURITY                 YES NO  YES NO
GMS_DIKO1216                   CONNECT                        NO  NO  YES NO
GMS_DIKO1216                   BO_ADMIN_RO_ROLE               NO  NO  YES NO




select * from dba_role_privs where grantee='GMS_DIKO1216';

==========
SQL> drop role PROVISIONER;

Role dropped.

SQL>
SQL> show parameter spfile

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
spfile                               string      /ora11204/orabase/oracle/dbs/s
                                                 pfileM2IUAT.ora
SQL> create pfile='/ora11204/orabase/oracle/dbs/initeM2IUAT_b4.ora' from spfile;

File created.

SQL>
===SQL> show parameter O7_DICTIONARY_ACCESSIBILITY

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
O7_DICTIONARY_ACCESSIBILITY          boolean     FALSE
SQL>
SQL> create pfile from spfile;



File created.

37.*************************FREE TABLESPACE QUERIES****************************

		SELECT Total.tablespace_name "Tablespace Name",
			   Free_space, Max_Size, (total_space-Free_space) Used_space, total_space
		FROM
		  (select tablespace_name, sum(bytes/1024/1024) Free_Space,max(bytes/1024/1024) Max_Size
			 from sys.dba_free_space
			group by tablespace_name
		  ) Free,
		  (select tablespace_name,  sum(bytes/1024/1024) TOTAL_SPACE
			 from sys.dba_data_files
			group by tablespace_name
		  ) Total
		WHERE Free.Tablespace_name = Total.tablespace_name;

OR

		ttitle -    
		center  'Database Freespace Summary'  skip 2  
		comp sum of nfrags totsiz avasiz on report 
		break on report  
		col tsname  format         a16 justify c heading 'Tablespace' 
		col nfrags  format     999,990 justify c heading 'Free|Frags' 
		col mxfrag  format 999,999,990 justify c heading 'Largest|Frag (KB)' 
		col totsiz  format 999,999,990 justify c heading 'Total|(KB)' 
		col avasiz  format 999,999,990 justify c heading 'Available|(KB)' 
		col pctusd  format         990 justify c heading 'Pct|Used'  

		select total.tablespace_name tsname,   
			count(free.bytes) nfrags,   
			nvl(max(free.bytes)/1024,0) mxfrag,   
			total.bytes/1024 totsiz,   
			nvl(sum(free.bytes)/1024,0) avasiz,   
			(1-nvl(sum(free.bytes),0)/total.bytes)*100 pctusd 
		from dba_data_files  total, dba_free_space free 
		where total.tablespace_name = free.tablespace_name(+)   
		and total.file_id=free.file_id(+)
		group by total.tablespace_name,total.bytes;

OR

		with ts as
		 (select name,blocksize,ts#,bitmapped from ts$)
		 select /*+ RULE */ a.name "Tablespace Name",total "Total Space",total-free "Used Space",free "Free Space",(free/total)*100 "% Free" from
		 (select
		 ts.name,
		 sum(f.length * ts.blocksize/1024/1024) free
		 from ts,sys.fet$ f
		 where ts.ts# = f.ts#
		 and ts.bitmapped = 0
		 group by ts.name
		 )a,
		 (select ts.name,
		 sum((ts.blocksize * f.blocks)/1024/1024) Total
		 from sys.file$ f,ts
		 where f.ts# = ts.ts#
		 and bitmapped=0
		 group by ts.name
		 )b
		 where a.name=b.name
		 union all
		 SELECT name,Total,total-free,free,(free/total)*100 "% used" from
		 (select name,
		 sum(round(KTFBHCSZ*blocksize/1024/1024,2)) total,
		 sum(round(KTFBHCFREE*blocksize/1024/1024,2)) free
		 FROM x$ktfbhc,ts where ts#=KTFBHCTSN
		 group by name )order by 5;

38.****************************** Archive Apply timing details *************************************************

		alter session set nls_date_format='dd-mon-yyyy hh24:mi:ss';

		set lines 150
		set pages 5000
		select  TIMESTAMP,completion_time "ArchTime",
				SEQUENCE#,round((blocks*block_size)/(1024*1024),1) "SizeM",
				round((TIMESTAMP-lag(TIMESTAMP,1,TIMESTAMP) OVER (order by TIMESTAMP))*24*60*60,1) "Diff(sec)",
				round((blocks*block_size)/1024/ decode(((TIMESTAMP-lag(TIMESTAMP,1,TIMESTAMP)
				OVER (order by TIMESTAMP))*24*60*60),0,1,
				(TIMESTAMP-lag(TIMESTAMP,1,TIMESTAMP) OVER (order by TIMESTAMP))*24*60*60),1) "KB/sec",
				round((blocks*block_size)/(1024*1024)/ decode(((TIMESTAMP-lag(TIMESTAMP,1,TIMESTAMP)
				OVER (order by TIMESTAMP))*24*60*60),0,1,
				(TIMESTAMP-lag(TIMESTAMP,1,TIMESTAMP) OVER (order by TIMESTAMP))*24*60*60),3) "MB/sec",
				round(((lead(TIMESTAMP,1,TIMESTAMP) over (order by TIMESTAMP))-completion_time)*24*60*60,1) "Lag(sec)"
		from v$archived_log a, v$dataguard_status dgs
		where a.name = replace(dgs.MESSAGE,'Media Recovery Log ','')
		and dgs.FACILITY = 'Log Apply Services'
		order by TIMESTAMP desc;
		
39.**************************archive generation**************************

select to_char(COMPLETION_TIME,'DD/MON/YYYY') Day,
sum(blocks*block_size)/1048576/1024 "Size(GB)",
count(sequence#) "Total Archives"
from (select distinct sequence#,
thread#,
COMPLETION_TIME,
blocks,
block_size
from v$archived_log
where sequence# between &start_sq_number and &end_sq_number )
group by to_char(COMPLETION_TIME,'DD/MON/YYYY')
/

		set pages 1000
		set lines 200
		select trunc(first_time) on_date,
			   min(sequence#) min_sequence,
			   max(sequence#) max_sequence,
			   max(sequence#) - min(sequence#) nos_archives,sum((blocks*block_size)/1024/1024/1024) req_space_GB from v$archived_log  where dest_id=1 group by trunc(first_time) order by trunc(first_time);
10.51.24.238
HOURLY Statistics:
		set pages 1000
		set lines 200
		select trunc(first_time) on_date,
			   min(sequence#) min_sequence,
			   max(sequence#) max_sequence,
			   max(sequence#) - min(sequence#) nos_archives,sum((blocks*block_size)/1024/1024/1024) req_space_GB from v$archived_log  where dest_id=1 group by trunc(first_time) order by trunc(first_time);
		select to_char(first_time,'dd-mon-yy hh24') on_date,
			   min(sequence#) min_sequence,
			   max(sequence#) max_sequence,
			   max(sequence#) - min(sequence#) nos_archives,
			   (max(sequence#) - min(sequence#)) * log_avg_mb req_space_mb
		from   v$log_history,
			   (select avg(bytes/1024/1024) log_avg_mb
				from   v$log)
		group  by to_char(first_time,'dd-mon-yy hh24'), thread#, log_avg_mb
		order by 1
		/
OR
		set pages 1000
		select trunc(COMPLETION_TIME,'HH') Hour,thread# , round(sum(BLOCKS*BLOCK_SIZE)/1048576) MB,count(*) Archives from v$archived_log
		group by trunc(COMPLETION_TIME,'HH'),thread#  order by 1 ;

		SELECT * FROM (
		SELECT * FROM (
		SELECT TO_CHAR(FIRST_TIME, 'DD/MM') AS "DAY"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '00', 1, 0)), '999') "00:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '01', 1, 0)), '999') "01:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '02', 1, 0)), '999') "02:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '03', 1, 0)), '999') "03:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '04', 1, 0)), '999') "04:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '05', 1, 0)), '999') "05:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '06', 1, 0)), '999') "06:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '07', 1, 0)), '999') "07:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '08', 1, 0)), '999') "08:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '09', 1, 0)), '999') "09:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '10', 1, 0)), '999') "10:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '11', 1, 0)), '999') "11:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '12', 1, 0)), '999') "12:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '13', 1, 0)), '999') "13:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '14', 1, 0)), '999') "14:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '15', 1, 0)), '999') "15:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '16', 1, 0)), '999') "16:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '17', 1, 0)), '999') "17:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '18', 1, 0)), '999') "18:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '19', 1, 0)), '999') "19:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '20', 1, 0)), '999') "20:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '21', 1, 0)), '999') "21:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '22', 1, 0)), '999') "22:00"
		, TO_NUMBER(SUM(DECODE(TO_CHAR(FIRST_TIME, 'HH24'), '23', 1, 0)), '999') "23:00"
		FROM V$LOG_HISTORY
		WHERE extract(year FROM FIRST_TIME) = extract(year FROM sysdate)
		GROUP BY TO_CHAR(FIRST_TIME, 'DD/MM')
		) ORDER BY TO_DATE(extract(year FROM sysdate) || DAY, 'YYYY DD/MM') DESC
		) WHERE ROWNUM < 20;
		
		By Nazir sir ,
		
		
		Set linesize 200 pagesize 1000
column day format a3
column total format 9999
column h00 format 999
column h01 format 999
column h02 format 999
column h03 format 999
column h04 format 999
column h04 format 999
column h05 format 999
column h06 format 999
column h07 format 999
column h08 format 999
column h09 format 999
column h10 format 999
column h11 format 999
column h12 format 999
column h13 format 999
column h14 format 999
column h15 format 999
column h16 format 999
column h17 format 999
column h18 format 999
column h19 format 999
column h20 format 999
column h21 format 999
column h22 format 999
column h23 format 999
column h24 format 999
break on report
compute max of "total" on report
compute max of "h00" on report
compute max of "h01" on report
compute max of "h02" on report
compute max of "h03" on report
compute max of "h04" on report
compute max of "h05" on report
compute max of "h06" on report
compute max of "h07" on report
compute max of "h08" on report
compute max of "h09" on report
compute max of "h10" on report
compute max of "h11" on report
compute max of "h12" on report
compute max of "h13" on report
compute max of "h14" on report
compute max of "h15" on report
compute max of "h16" on report
compute max of "h17" on report
compute max of "h18" on report
compute max of "h19" on report
compute max of "h20" on report
compute max of "h21" on report
compute max of "h22" on report
compute max of "h23" on report
compute sum of NUM on report
compute sum of GB on report
compute sum of MB on report
compute sum of KB on report

REM Script to Report the Redo Log Switch History

alter session set nls_date_format='DD MON YYYY';
select thread#, trunc(completion_time) as "date", to_char(completion_time,'Dy') as "Day", count(1) as "total",
sum(decode(to_char(completion_time,'HH24'),'00',1,0)) as "h00",
sum(decode(to_char(completion_time,'HH24'),'01',1,0)) as "h01",
sum(decode(to_char(completion_time,'HH24'),'02',1,0)) as "h02",
sum(decode(to_char(completion_time,'HH24'),'03',1,0)) as "h03",
sum(decode(to_char(completion_time,'HH24'),'04',1,0)) as "h04",
sum(decode(to_char(completion_time,'HH24'),'05',1,0)) as "h05",
sum(decode(to_char(completion_time,'HH24'),'06',1,0)) as "h06",
sum(decode(to_char(completion_time,'HH24'),'07',1,0)) as "h07",
sum(decode(to_char(completion_time,'HH24'),'08',1,0)) as "h08",
sum(decode(to_char(completion_time,'HH24'),'09',1,0)) as "h09",
sum(decode(to_char(completion_time,'HH24'),'10',1,0)) as "h10",
sum(decode(to_char(completion_time,'HH24'),'11',1,0)) as "h11",
sum(decode(to_char(completion_time,'HH24'),'12',1,0)) as "h12",
sum(decode(to_char(completion_time,'HH24'),'13',1,0)) as "h13",
sum(decode(to_char(completion_time,'HH24'),'14',1,0)) as "h14",
sum(decode(to_char(completion_time,'HH24'),'15',1,0)) as "h15",
sum(decode(to_char(completion_time,'HH24'),'16',1,0)) as "h16",
sum(decode(to_char(completion_time,'HH24'),'17',1,0)) as "h17",
sum(decode(to_char(completion_time,'HH24'),'18',1,0)) as "h18",
sum(decode(to_char(completion_time,'HH24'),'19',1,0)) as "h19",
sum(decode(to_char(completion_time,'HH24'),'20',1,0)) as "h20",
sum(decode(to_char(completion_time,'HH24'),'21',1,0)) as "h21",
sum(decode(to_char(completion_time,'HH24'),'22',1,0)) as "h22",
sum(decode(to_char(completion_time,'HH24'),'23',1,0)) as "h23"
from
v$archived_log
where first_time > trunc(sysdate-10)
and dest_id = (select dest_id from V$ARCHIVE_DEST_STATUS where status='VALID' and type='LOCAL')
group by thread#, trunc(completion_time), to_char(completion_time, 'Dy') order by 2,1;
		
		
40.LOG SWITCH INFOINFORMATION:--------------------------
		select trunc(first_time, 'HH') , count(*)
		from v$loghist
		group by  trunc(first_time, 'HH') order by 1;
		
41.Session generating lots of redo:---------------------------------
		SELECT s.sid, s.serial#, s.username, s.program,s.sql_id ,
		i.block_changes
		FROM v$session s, v$sess_io i
		WHERE s.sid = i.sid
		ORDER BY 6 desc;
		
42.*********************** Redo genrated per session *****************************
		set linesize 120
		col module format a20
		col osuser format a20
		select * from
		(
		sELECT s.sid, module, osuser,username,status, sql_hash_value, value redo, to_char(logon_time, 'dd/mm/yyyy hh24:mi:ss') LOGON
		FROM gv$session s, gv$sesstat ss, gv$statname sn
		WHERE s.sid =   ss.sid
		AND ss.statistic# = sn.statistic#
		AND name = 'redo size'
		ORDER BY redo  desc
		)
		where rownum <=5
		/
OR
		set linesize 120
		col module format a20
		select * from
		(
		SELECT distinct s.SESSION_ID, module, USER_ID,s.sql_id,value redo, to_char(SAMPLE_TIME, 'dd/mm/yyyy hh24:mi:ss') lt
		FROM DBA_HIST_ACTIVE_SESS_HISTORY s, DBA_HIST_SYSSTAT ss
		WHERE s.SNAP_ID =   ss.SNAP_ID
		AND ss.STAT_NAME = 'redo size'
		and s.SNAP_ID between 8610 and 8620
		ORDER BY redo  desc
		)
		where rownum <=5
		/

	Total Redo By Session:-

		set linesize 121
		col module format a30

		SELECT module, osuser, sql_hash_value, value redo
		FROM gv$session s, gv$sesstat ss, gv$statname sn
		WHERE s.sid = ss.sid
		AND ss.statistic# = sn.statistic#
		AND name = 'redo size'
		ORDER BY redo;

	Total Redo By Session Per Time Period:-

		SELECT module, osuser, sql_hash_value, value/(sysdate-logon_time) redo
		FROM gv$session s, gv$sesstat ss, gv$statname sn
		WHERE s.sid = ss.sid
		AND ss.statistic# = sn.statistic#
		AND name = 'redo size'
		ORDER BY redo;


	Redo Generated by SID:-

		col sid form 9999
		col username form a10
		col value Head "Redo|Generated|in MB" form 9999999999.999
		col program form a30
		col logtime head "Logon Time" form a15

		SELECT st.sid, se.username, TO_CHAR(se.logon_time,'dd-mon-yy hh24:mi')
		logtime, se.program, (value/1048576) VALUE
		FROM gv$sesstat st, gv$statname sn, gv$session se
		WHERE sn.name = 'redo size'
		AND sn.statistic# = st.statistic#
		AND st.sid = se.sid
		AND value <> 0
		ORDER BY 5;


	Redo Generation by SID:-

		col value format 9999999
		SELECT s.sid, n.name, s.value
		FROM gv$sesstat s, gv$statname n
		WHERE n.name = 'redo blocks written'
		AND s.statistic# = n.statistic#
		ORDER BY value;
		
43.***************************** Rollback Remaining ****************************

		select  usn, state, undoblockstotal "Total", undoblocksdone "Done", undoblockstotal-undoblocksdone "ToDo",
		decode(cputime,0,'unknown',
		sysdate+(((undoblockstotal-undoblocksdone) / (undoblocksdone / cputime)) / 86400)) "Estimated time to complete"  
		from v$fast_start_transactions where pid=&pid;

			Below is working 
			-*-
		select a.sid, a.username, b.xidusn, b.used_urec, b.used_ublk 
		from v$session a, v$transaction b 
		where a.saddr=b.ses_addr and a.sid=&sid;
			-*-

		speed up the rollback process alter system set fast_start_parallel_rollback='HIGH';


		select sum(distinct(ktuxesiz)) from x$ktuxe where ktuxecfl = 'DEAD'
		
		to speed up rollback need to increase below parameter 
	
	fast_start_mttr_target >> from 0 to 3600

	alter system set fast_start_mttr_target=3600 scope=both;

		
============================================Rollback Remaining working==========================================


COLUMN sid FORMAT 9999
COLUMN serial# FORMAT 99999

SELECT s.username,
s.sid,
s.serial#,
t.used_ublk,
t.used_urec,
rs.segment_name,
r.rssize,
r.status
FROM v$transaction t,
v$session s,
v$rollstat r,
dba_rollback_segs rs
WHERE s.saddr = t.ses_addr
AND t.xidusn = r.usn
AND rs.segment_id = t.xidusn
ORDER BY t.used_ublk DESC;

44.*****************What are the holders waiting for?**************************
		 
		select sid,substr(event,1,30),wait_time 
		from v$session_wait 
		where sid in (select sid from x$kglpn , v$session 
		where KGLPNHDL in (select p1raw from v$session_wait 
		where wait_time=0 and event like 'library cache lock%') 
		and KGLPNMOD <> 0 
		and v$session.saddr=x$kglpn.kglpnuse ); 
		
45.***********************To identify SQL: ************************************

		select sid,sql_text 
		from v$session, v$sqlarea 
		where v$session.sql_address=v$sqlarea.address 
		and sid=&sid; 
		
46.*************************************** dbms_Stats package default value *******************************

		SELECT sname AS parameter, nvl(spare4,sval1) AS default_value
		FROM sys.optstat_hist_control$
		WHERE sname IN ('CASCADE','ESTIMATE_PERCENT','DEGREE',
			  'METHOD_OPT','NO_INVALIDATE','GRANULARITY');
			  
47. SID FROM PID
		 set lines 150
		 set pages 500
		 col USERNAME for a15
		 col OSUSER for a8
		 col MACHINE for a15
		 col PROGRAM for a20
		 select  a.username, a.program , a.osuser ,a.machine,  a.sid, a.serial#, a.status from v$session a, v$process b  where a.paddr=b.addr and b.spid=&spid;
		 
48.Active Session History.
		Select * FROM SYS.DBA_HIST_ACTIVE_SESS_HISTORY 
		WHERE sample_time > TO_DATE('19-OCT-2018 11:29:00','DD-MON-YYYY HH24:MI:SS') 
		AND sample_time < TO_DATE('19-OCT-2018 11:31:00','DD-MON-YYYY HH24:MI:SS') 
		
49.***********************************to find the query plan with sql id *********************


select * from table(dbms_xplan.display_awr('8pccbrnmarund'));


		current running queries:

		set pagesize 300;
		set lines 100;
		col username for a20;
		col sql_text for a35;
		col logon_time for a25;
		set linesize 200;
		col  event for a30;
		col TO_CHAR(S.LOGON_TIME,'YYYY-MM-DDHH24:MI:SS') for a20;
		col spid for a10;
		select s.inst_id,S.sid,S.SERIAL#,s.event,s.username,s.sql_id,S.LAST_CALL_ET/60,TO_CHAR(s.LOGON_TIME,'yyyy-mm-dd hh24:mi:ss')
		FROM gv$session s ,gv$sqlarea A,gv$process p
		WHERE s.sql_hash_value= A.hash_value
		 and S.PADDR      = P.ADDR
		and  S.STATUS ='ACTIVE' and S.type='USER'; 
		
		
		set longc 3999 long 999999
		set pagesize 300;
		set lines 100;
		col username for a20;
		col sql_text for a90;
		col logon_time for a25;
		set linesize 200;
		col  event for a30;
		col TO_CHAR(S.LOGON_TIME,'YYYY-MM-DDHH24:MI:SS') for a20;
		col spid for a10;
		select s.inst_id,S.sid,S.LAST_CALL_ET/60,TO_CHAR(s.LOGON_TIME,'yyyy-mm-dd hh24:mi:ss'),a.sql_text
		FROM gv$session s ,gv$sqlarea A,gv$process p
		WHERE s.sql_hash_value= A.hash_value
		 and S.PADDR      = P.ADDR
		and  S.STATUS ='ACTIVE' and S.type='USER';
		
		
		
		set pagesize 300;
		set lines 100;
		col username for a20;
		col sql_text for a35;
		col logon_time for a25;
		set linesize 200;
		col  event for a30;
		col TO_CHAR(S.LOGON_TIME,'YYYY-MM-DDHH24:MI:SS') for a20;
		col spid for a10;
		select s.inst_id,S.sid,S.SERIAL#,s.event,s.username,s.sql_id,S.LAST_CALL_ET/60,TO_CHAR(s.LOGON_TIME,'yyyy-mm-dd hh24:mi:ss'),a.sql_text
		FROM gv$session s ,gv$sqlarea A,gv$process p
		WHERE s.sql_hash_value= A.hash_value
		 and S.PADDR      = P.ADDR
		and  S.STATUS ='ACTIVE' and S.type='USER'
		and a.sql_text like '%&text%';

================ current running 
set lines 200 
set pages 1000
col event format a60


PROMPT --> Top 25 Wait Events for active sessions

select * from
(select event,count(*) E_COUNT from v$session
where status='ACTIVE'
group by event
order by 2 desc)
where rownum < 26;

col sid format 999999
col sql format a35
col username format a15
col osuser format a10
col child format 99
col secs format 99999
col machine format a15
col event format a25
col state format a10

select  distinct
w.sid,s.username,s.osuser,substr(w.event,1,25) event,substr(s.machine,1,12) machine,substr(w.state,1,10) state,s.SQL_ID,s.SQL_CHILD_NUMBER CHILD,
substr(q.sql_text,1,33) "SQL",round(s.LAST_CALL_ET/60) "MINS"--,q.buffer_gets
from v$session_wait w,v$session s,v$sql q where  w.sid=s.sid
and s.SQL_HASH_VALUE=q.HASH_VALUE(+)
and s.status='ACTIVE'
and s.username is not null
and substr(w.event,1,25) not like 'SQL*Net message from clie%'
order by "MINS"
/
=============
		
		OMS
		
		7a4f5y1yyfnnx 6858
		
		select  b.sid,b.serial#,
prcsinstance,
prcstype,prcsname,
to_char(rqstdttm,'mm-dd-yy hh24:mi:ss') Start_Date,
oprid,
decode(runstatus,1,'Cancel',
           2, 'Delete',
           3, 'Error',
           4, 'Hold',
           5, 'Queued',
           6, 'Initiated',
           7, 'Processing',
           8, 'Cancelled',
           9, 'Success',
           10,'No Success',
           11,'Posted',
           12,'Not Posted',
           13,'Resend',
           14,'Posting',
           15,'Generated') "Status",
origprcsinstance
from PSPRCSQUE a, v$session b
where runstatus='7'
and b.process=to_char(a.sessionidnum)
and b.client_info is not null;
		
		
=============================== wait event / wait class =====================

Select a.event, a.total_waits, a.time_waited, a.average_wait From v$system_event a, v$event_name b, v$system_wait_class c Where a.event_id=b.event_id And b.wait_class#=c.wait_class# And c.wait_class = '&Enter_Wait_Class' order by average_wait desc;


Select wait_class, sum(time_waited), sum(time_waited)/sum(total_waits) Sum_Waits From v$system_wait_class Group by wait_class Order by 3 desc;

=======================================================
		
		
		
50.Top SQL
		
		
		select * from (
			select
				SQL_ID ,
				sum(decode(session_state,'ON CPU',1,0)) as CPU,
				sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
				sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
				sum(decode(session_state,'ON CPU',1,1)) as TOTAL
			from v$active_session_history
			where SQL_ID is not NULL
			group by sql_id
			order by sum(decode(session_state,'ON CPU',1,1))   desc
			)
		   where rownum <11;
			
			
			
		   
		   
		   LONG RUNNING
		   
			set line 150;
			col target for a35
			col EST_COMPLETION_TIME for a18
			col USERNAME for a12
			col SOFAR for 999999999
			col sid_serial for a10
			set pages 1000
			SELECT /*+ rule */ a.sid||','||a.serial#  "sid_serial", b.username, b.status, a.target || a.opname target , a.TOTALWORK, a.SOFAR SOFAR, a.TIME_REMAINING "TIME_REM",
			to_char(start_time+(sysdate-start_time) /(a.sofar/a.totalwork),'dd-mon-yy:hh:mi:ss') Est_completion_time,
			round((a.sofar/a.totalwork)*100,3) pct_comp,
			ELAPSED_SECONDS "ELAPS_SECS" FROM V$SESSION_LONGOPS a, V$SESSION b
			where a.time_remaining > 0
			and a.sid=b.sid
			order by a.time_remaining desc
			/ 


Dll Statements.
select dbms_metadata.get_ddl('&Object_type','&Object_name','&Owner') from dual;
set pagesize 299
set long 999
select dbms_metadata.get_ddl('PROCOBJ','&Job_name','&owner') from dual;


set lines 999
set pages 500
column START_TIME format a30;
column END_TIME format a30;
column STATUS format a30;
select * from (select INPUT_TYPE, to_char(START_TIME,'DD-MON-YYYY:HH24:MI:SS') START_TIME,
to_char(END_TIME,'DD-MON-YYYY:HH24:MI:SS') END_TIME,ELAPSED_SECONDS/60 ELAPSED_MINS,
STATUS,TRUNC(START_TIME) BKP_DATE,SESSION_KEY from V$RMAN_BACKUP_JOB_DETAILS order by BKP_DATE desc) 
where rownum <25
/
M@ncha$ter7
-------------------------  Database opatch version ---
root> opatch lsinventory

root> opatch lsinventory -display

opatch rerequisite.--------------------
opatch prereq CheckConflictAgainstOHWithDetail -ph ./

select * from sys.registry$history;
21:45
---------------------------------------- Datafile Addtion.----------------------------
col file_name for a70
col tablespace_name for a20
set lines 190
set pages 500
select  d.file_id,d.tablespace_name,d.file_name,v.CREATION_TIME,v.bytes/1024/1024
from dba_data_Files d , v$datafile v
where tablespace_name=upper('&tablespace_name')
and file_id=file#
order by v.CREATION_TIME;
---------------------------------Tempfile Addition---------------------------
col file_name for a70
col tablespace_name for a20
set lines 130
set pages 500
select  d.file_id,d.tablespace_name,d.file_name,v.CREATION_TIME,v.bytes/1024/1024
from dba_temp_Files d , v$tempfile v
where tablespace_name=upper('&tablespace_name')
and file_id=file#
order by v.CREATION_TIME;

-----------------------Restoration Status-----Duplicate cammand-----------

TTITLE OFF
SET HEAD OFF
SELECT 'Throughput: '||
       ROUND(SUM(v.value/1024/1024),1) || ' Meg so far @ ' ||
       ROUND(SUM(v.value     /1024/1024)/NVL((SELECT MIN(elapsed_seconds)
            FROM v$session_longops
            WHERE opname          LIKE 'RMAN: aggregate input'
              AND sofar           != TOTALWORK
              AND elapsed_seconds IS NOT NULL
       ),SUM(v.value     /1024/1024)),2) || ' Meg/sec'
 FROM gv$sesstat v, v$statname n, gv$session s
WHERE v.statistic# = n.statistic#
  AND n.name       = 'physical write total bytes'
  AND v.sid        = s.sid
  AND v.inst_id    = s.inst_id
  AND s.program LIKE 'rman@%'
GROUP BY n.name
/

******************* Undo recover session ******************** 
select usn, state, undoblockstotal "Total", undoblocksdone "Done", undoblockstotal-undoblocksdone "ToDo", 
decode(cputime,0,'unknown',sysdate+(((undoblockstotal-undoblocksdone) / (undoblocksdone / cputime)) / 86400)) "Estimated time to complete" from v$fast_start_transactions;

=====================Bind Verriable in query ==============================

set head on heads on
col name for a25
col DATATYPE_STRING for a15
col VALUE_STRING for a40
col VAL for a40
select distinct sql_id, name, position, DATATYPE_STRING dtype, VALUE_STRING val from v$sql_bind_capture
where sql_id='&sql_id'
--and trunc(last_captured)=trunc(sysdate)
order by position

  -----------------------------------------------
  IMPSTBL_IDX
  ----------------------------------------Row Lock Contention--------------------------------------------------------------------------
			select
				sid,
				sql_text 
			from
				v$session s,
				v$sql q 
			where
				sid in
				(select
				sid
				from
				v$session
			where
				state in ('WAITING')
			and
				wait_class != 'Idle'
			and 
				event='enq: TX - row lock contention'
			and 
				(q.sql_id = s.sql_id or q.sql_id = s.prev_sql_id));
			
************The blocking session is:*********************************
			
			select
				blocking_session,
				sid,    serial#,
				wait_class,
				seconds_in_wait 
			from
				v$session 
			where
				blocking_session is not NULL
			order by
				blocking_session;
---------------------------------------------------------------------------Temp File Add --------------------
 alter session set events='60063';
-----------------archive applied at perticuler time -------------------------------------------------------
select THREAD#,SEQUENCE#, to_char(FIRST_TIME,'dd/mm/yy hh24:mi'),to_char(NEXT_TIME,'dd/mm/yy hh24:mi') from v$archived_log where to_char(next_time,'dd/mm/yy hh24:mi') = '02/01/19 02:21';
------------------------------------------------------------------------------------------

------------------------------Release Trace--------------------------------------------------------------------
/usr/bin/find /u01/app/oracle/IDCMSDB/diag/diag/rdbms/idcmsdb_dr/IDCMSDB1/alert -name "*.xml" -mtime +7 -exec /usr/bin/rm  {} \;
/usr/bin/find /u01/app/oracle/IDCMSDB/diag/diag/rdbms/idcmsdb_dr/IDCMSDB1/trace -name "*.trc" -mtime +5 -exec /usr/bin/rm  {} \;
/usr/bin/find /u01/app/oracle/IDCMSDB/diag/diag/rdbms/idcmsdb_dr/IDCMSDB1/trace -name "*.trm" -mtime +15 -exec /usr/bin/rm  {} \;
/usr/bin/find /u01/app/oracle/IDCMSDB/diag/diag/rdbms/idcmsdb_dr/IDCMSDB1/cdump -name "*core" -mtime +7 -exec /usr/bin/rm  {} \;
--------------------------------------------------------------------------------------------------------------------------------

create disk group
create diskgroup REDO_BUNKER_LS external redundancy disk '' ATTRIBUTE 'compatible.asm'='12.1.0.2'; 

------------------------ Gather Fixed Objects Stats---------
1.exec dbms_stats.gather_dictionary_stats;

2.EXEC DBMS_STATS.GATHER_FIXED_OBJECTS_STATS;

3.EXEC DBMS_STATS.gather_system_stats('start') ;

To Delete SYS STAT :
EXEC DBMS_STATS.DELETE_SYSTEM_STATS;


---------------------Past SQL-------------------------
select ltrim(sq.sql_text)
  from v$sql sq, v$session se, v$open_cursor oc
 where sq.sql_id = oc.sql_id
   and se.saddr = oc.saddr
   and se.sid = oc.sid
   AND sq.sql_text like '%CUSTOMER_CATEGORY%';
 order by oc.LAST_SQL_ACTIVE_TIME desc;
 
 2:------------
 
 
 select h.sample_time
, u.username
, h.machine
, s.sql_text
, h.*
from dba_hist_active_sess_history h
inner join v$sql s
on s.sql_id = h.sql_id
left outer join dba_users u
on u.user_id = h.user_id
where s.sql_text like 'DELETE%'
order by h.sample_time desc;


 ------------------------------------------------------------Enable trace for mrp------------
 1)On the Standby, find the MRP pid: 
select process,pid from V$managed_standby where process like '%MRP%'; 

2)To turn on the tracing: 
SQL> oradebug setospid <MRPPID> 
SQL> oradebug unlimit 
SQL> oradebug Event 10046 trace name context forever, level 12 

3) Wait about 10mins 

4) To turn off the tracing: 
SQL> oradebug setospid <MRPPID> 
SQL> oradebug Event 10046 trace name context off 
SQL> oradebug tracefile_name 


column line format a79
set heading off
select 'ospid: ' || p.spid || ' # ''' ||s.sid||','||s.serial#||''' '||
s.osuser || ' ' ||s.machine ||' '||s.username ||' '||s.program line
from v$session s , v$process p
where p.addr = s.paddr
and s.username <> ' ';

---------------------------------------TAR Backup------------------------
$cd <RDBMS trace directory> 
$ grep "<Year in YY>-<Month in MM >-<Date in DD> <Hour in HH>" *.trc | awk -F: '{print $1}' | sort -u |xargs tar cvf trace.`hostname`.`date +%Y%m%d%H%M%S`.tar 

------------------imps stat copy
exec dbms_stats.copy_table_stats('IMPS','IMPS_TRANLOG',SYS_P5964,SYS_P6163);
select OWNER,TABLE_NAME,PARTITION_NAME,STALE_STATS,NUM_ROWS,last_analyzed from dba_tab_statistics where owner='UPIPROD' and TABLE_NAME='UPI_TRANLOG';
select OWNER,TABLE_NAME,PARTITION_NAME,STALE_STATS,NUM_ROWS,last_analyzed from dba_tab_statistics where owner='UPIPROD' and TABLE_NAME='UPI_TRANLOG_META';
------------------------PIVOT--------------------
SQL> l
  1  select * from (
  2    select DB_NAME, TABLESPACE_NAME ,CREATION_TIME ,BYTES
  3    from   gazi_datafile_2
  4  )
  5  pivot (sum(BYTES) for CREATION_TIME in (
  6    2006,2007,2009,2012,2013,2017,2018,2019
  7    )
  8  )
  9* order  by DB_NAME
SQL> save /tmp/gazi.sql
SP2-0540: File "/tmp/gazi.sql" already exists.
Use "SAVE filename[.ext] REPLACE".
SQL> save /tmp/gazi2.sql
Created file /tmp/gazi2.sql


Create table GAZI_DATAFILE_3 as 
 
 select * from (
   select DB_NAME, TABLESPACE_NAME ,CREATION_TIME ,BYTES
   from   gazi_datafile_2
 )
 pivot (sum(BYTES) for CREATION_TIME in (
   2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019
   )
 )
 order  by DB_NAME;
 
-----------------------------------------------------add table in buffer-------------------------
01:08:07 SQL> ALTER TABLE UPIPROD.UPI_SOURCE_CHANNELS STORAGE (BUFFER_POOL KEEP);

---------------------- check iocp -----------------------------------
lsdev | grep iocp
-------------------------------------
Using Oracle Data Guard between IBM AIX on Power systems and Oracle Solaris on SPARC systems (Doc ID 1982638.1)
Primary Note for Oracle GoldenGate Core Product Patch Sets (Doc ID 1645495.1)

-------------------------------------  rac listener -------------------

 EXECUTE dbms_registry_sys.validate_components;
 execute sys.validate_ordim;

----------------------------------------------Create RestorePoint-------------------

CREATE RESTORE POINT BEFORE_BUILD_20250828 GUARANTEE FLASHBACK DATABASE;

select name,database_role,open_mode,flashback_on,log_mode from v$database;
sho parameter reco

col NAME for a20
col TIME for a40
SELECT NAME, SCN, TIME, DATABASE_INCARNATION#, GUARANTEE_FLASHBACK_DATABASE, STORAGE_SIZE FROM V$RESTORE_POINT WHERE GUARANTEE_FLASHBACK_DATABASE='YES';

SELECT NAME, SCN, TIME, DATABASE_INCARNATION#, GUARANTEE_FLASHBACK_DATABASE, STORAGE_SIZE FROM V$RESTORE_POINT WHERE GUARANTEE_FLASHBACK_DATABASE='YES';

==================Database incarnation  ==================
select
 incarnation#, resetlogs_change#
from
 v$database_incarnation;
 
 
=========================================

---------------------Diskgroup ADD-------------------------
Linux : ----------   oracleasm
Sun Solaris : ----   mknod
IBM AXI:----------   hexdisk directly add disk in diskgroup

For AIX
ls -lrt hdisk57
hdisk57		6001738C7C80536F00000000000142B9  102400 19, 61

cd /dev/ASMDISKS
mknod FRA_FLASH_0000 c 19 97
chmod 660 FRA_FLASH_0000
chown grid:asmadmin FRA_FLASH_0000

create diskgroup PFMS_REDO02_NEW external redundancy disk '/dev/ASMDISKS/PFMS_FLASH_REDO02_0000' ,'/dev/ASMDISKS/PFMS_FLASH_REDO02_0001' attribute 'compatible.rdbms'='10.1.0.0.0', 'compatible.asm'='12.1.0.0';
alter diskgroup CMSDATA add disk '/asmdisks/CMSAUTHJPR_DATA_disk8' drop disk CMSDATA_0000 rebalance power 11;
select * from gv$asm_operation;

 alter diskgroup OEMDB_BUNKER_REDO dismount;
====================For linux============================
alter DISKGROUP ARCH add 
FAILGROUP ARCH_FG1 DISK 
'/dev/raw/raw118' NAME ARCH_0011,
'/dev/raw/raw119' NAME ARCH_0012,
'/dev/raw/raw120' NAME ARCH_0013,
'/dev/raw/raw121' NAME ARCH_0014,
'/dev/raw/raw122' NAME ARCH_0015
FAILGROUP ARCH_FG2 DISK
'/dev/raw/raw218' NAME ARCH_0016,
'/dev/raw/raw219' NAME ARCH_0017,
'/dev/raw/raw220' NAME ARCH_0018,
'/dev/raw/raw221' NAME ARCH_0019,
'/dev/raw/raw222' NAME ARCH_0020;

===============mknode solaris ====================------------
cd /dev/rdsk
ls -ltr c5t50060163086039B2d28s6 
lrwxrwxrwx   1 root     root         102 Dec 12 14:09 c5t50060163086039B2d28s6 -> ../../devices/pci@400/pci@2/pci@0/pci@1/pci@0/pci@3/SUNW,emlxs@0/fp@0,0/ssd@w50060163086039b2,1c:g,raw 

ls -lrt  ../../devices/pci@400/pci@2/pci@0/pci@1/pci@0/pci@3/SUNW,emlxs@0/fp@0,0/ssd@w50060163086039b2,1c:g,raw 
asmadmin 244, 678 Dec 13 11:38 ../../devices/pci@400/pci@2/pci@0/pci@1/pci@0/pci@3/SUNW,emlxs@0/fp@0,0/ssd@w50060163086039b2,1c:g,raw 

cd /dev/ASMDISKS
mknod IAUTODB_DATA_1 c 244 678
chown -R grid:asmadmin PRIMEUAT*
chmod 660 IAUTODB_DATA_1 
-------------------------------------------------Create OCR DISKGROUP-----------------------------------------------------------
------------------------
OCR / Vote disk Maintenance Operations: (ADD/REMOVE/REPLACE/MOVE) (Doc ID 428681.1)

backup ocr and votedisk
create diskgroup


./ocrconfig -showbackup
./ocrconfig -manualbackup

create diskgroup OCRVOTE high redundancy disk '/dev/ASMDISKS/OCRDATA_FLASH_0002' ,'/dev/ASMDISKS/OCRDATA_FLASH_0004' ,'/dev/ASMDISKS/OCRDATA_FLASH_0003','/dev/ASMDISKS/OCRDATA_FLASH_0000','/dev/ASMDISKS/OCRDATA_FLASH_0001'
attribute 'compatible.rdbms'='10.1.0.0.0', 'compatible.asm'='12.1.0.0';

select name, state, type from v$asm_diskgroup;

./ocrconfig -add +OCRVOTE

./ocrconfig -delete +OCRDATA

./ocrcheck

./crsctl replace votedisk +OCRVOTE

./crsctl query css votedisk



create pfile='/tmp/init_06Mar19.ora' from spfile;


create spfile='+OCRVOTE' from pfile='/tmp/init_06Mar19.ora';


 TFA Collector - TFA with Database Fort Tools Bundle (Doc ID 1513912.1)
 --------------------------Running Job Details---------------------------
 dba_scheduler_running_chains
dba_scheduler_running_jobs
v$scheduler_running_jobs
dba_scheduler_job_run_details  --------------Good

set lines 200 pages 300
col OWNER for a15
col LOG_DATE for a45 
col ACTUAL_START_DATE for a45 
col JOB_NAME for a30 
col STATUS for a15
select OWNER,LOG_DATE,JOB_NAME,ACTUAL_START_DATE,RUN_DURATION,STATUS from DBA_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME like '%&name%'
and LOG_DATE > sysdate -15 order by ACTUAL_START_DATE ASC
/

set lines 200 pages 300
col OWNER for a15
col LOG_DATE for a45 
col ACTUAL_START_DATE for a45 
col JOB_NAME for a22 
col STATUS for a15
select a.OWNER,a.LOG_DATE,a.JOB_NAME,a.ACTUAL_START_DATE,a.RUN_DURATION,a.STATUS from (select OWNER,LOG_DATE,JOB_NAME,ACTUAL_START_DATE,RUN_DURATION,STATUS from DBA_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME='&name'
and LOG_DATE > sysdate -1 order by ACTUAL_START_DATE desc  ) a where rownum < 10
/

set lines 200 pages 300
col OWNER for a15
col LOG_DATE for a45 
col ACTUAL_START_DATE for a45 
col JOB_NAME for a22 
col STATUS for a15
select a.OWNER,a.LOG_DATE,a.JOB_NAME,a.ACTUAL_START_DATE,a.RUN_DURATION,a.STATUS from (select OWNER,LOG_DATE,JOB_NAME,ACTUAL_START_DATE,RUN_DURATION,STATUS from DBA_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME='&name'
and LOG_DATE > sysdate -1 order by ACTUAL_START_DATE desc  ) a where rownum < 10
/



set lines 200 pages 300
col OWNER for a15
col LOG_DATE for a45 
col ACTUAL_START_DATE for a45 
col JOB_NAME for a22 
col STATUS for a15
select a.OWNER,a.JOB_NAME,a.ERRORS from (select OWNER,LOG_DATE,JOB_NAME,ACTUAL_START_DATE,RUN_DURATION,STATUS,ERRORS from DBA_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME='&name'
and LOG_DATE > sysdate -2 order by ACTUAL_START_DATE desc  ) a where rownum < 10
/


select OWNER,LOG_DATE,JOB_NAME,ACTUAL_START_DATE,RUN_DURATION,STATUS,ERRORS from DBA_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME='&name'
and LOG_DATE > sysdate -0.9 order by ACTUAL_START_DATE asc 

select  t.state, t.job_name, t.run_count, (t.next_run_date - systimestamp ) seconds_to_run ,t.next_run_date,systimestamp
               from all_scheduler_jobs t;
			   


job_name in ('JOB_UCS_Interactions_Test') order by ACTUAL_START_DATE;

select OWNER,JOB_NAME,SESSION_ID,RUNNING_INSTANCE from dba_scheduler_running_jobs where JOB_NAME in ('&job_name');
ICICI_REPORTS_JOBS';
To stop job :DBMS_SCHEDULER.stop_job (JOB_NAME => 'owner.RMAN_INC');


check job sheduled or not**********************
select OWNER,JOB_NAME,START_DATE,END_DATE,STATE,LAST_RUN_DURATION from all_scheduler_jobs where JOB_NAME='ICICI_REPORTS_JOBS' it should be running
  1* select OWNER,JOB_NAME,LAST_RUN_DURATION,LAST_START_DATE,STATE from dba_scheduler_jobs where JOB_NAME='ICICI_REPORTS_JOBS'
----------------------table accessing sql ---------------------
select a.SQL_ID,a.SQL_TEXT,b.SID,b.SERIAL# from v$sql a ,v$session b where a.sql_id=b.sql_id and b.sid in 
( select sid from v$access where object in ('REC_TPZFICL_UNRECON','REC_TPZCCH_UNRECON'));

--------------- SGA Statistics -------------------------------------

select name,bytes/1024/1024 from v$sgainfo;


-----------------------------Shared Pool Analysis-------------------

To find the current shared_pool consumed size
select
   component,
   current_size/1024/1024/1024        "CURRENT_SIZE",
   min_size/1024/1024/1024            "MIN_SIZE",
   user_specified_size/1024/1024/1024 "USER_SPECIFIED_SIZE",
   last_oper_type                 "TYPE"
from
   v$sga_dynamic_components;
---------------------------------------------
select pool,sum(bytes)/1024/1024 from v$sgastat group by pool;

To find the free memory in shared pool--------------------------------------
select pool,name,bytes/1024/1024 from v$sgastat WHERE name = 'free memory';
select pool,name,sum(bytes/1024/1024) from v$sgastat WHERE name = 'free memory' and pool='streams pool' group by pool,name ;

To find what is consuming the shared pool----------------------------------------
select pool,name,bytes/1024/1024 from v$sgastat WHERE name !='free memory' and pool='shared pool' order by bytes;

------------------------------------Fragmentation----------------------------------------------------------------
select 
owner,table_name,tablespace_name,
blocks,
num_rows,
avg_row_len,round(((blocks*8/1024)),2)  "TOTAL_SIZE", 
round((num_rows*avg_row_len/1024/1024),2) "ACTUAL_SIZE", 
round(((blocks*8/1024)-(num_rows*avg_row_len/1024/1024)),2) "FRAGMENTED_SPACE"
from dba_tables 
where owner <> 'SYS' 
and round(((blocks*8/1024)-(num_rows*avg_row_len/1024/1024)),2) > 500
order by FRAGMENTED_SPACE desc;
------------------------------------------------Dr Sync Status -----------------------------------
set lines 110
select p.prim_max_sequence,
         d.dr_max_archived_sequence,
         ad.dr_max_applied_sequence,
         p.prim_max_sequence-d.dr_max_archived_sequence archive_lag_in_dr,
         p.prim_max_sequence-ad.dr_max_applied_sequence applied_lag_in_dr
from
(select max(sequence#) prim_max_sequence from v$archived_log where dest_id=1 and archived='YES') p,
(select max(sequence#) dr_max_archived_sequence from v$archived_log where standby_dest='YES' and archived='YES') d,
(select max(sequence#) dr_max_applied_sequence from v$archived_log where standby_dest='YES' and archived='YES' and applied='YES') ad;

set lines 150
select p.prim_max,
       f.fall_max_archived,
       d.dr_max_archived,
       af.fall_max_applied,
       ad.dr_max_applied,
       p.prim_max-f.fall_max_archived archive_lag_fall,
       p.prim_max-d.dr_max_archived archive_lag_dr,
       p.prim_max-af.fall_max_applied applied_lag_fall,
       p.prim_max-ad.dr_max_applied applied_lag_dr
from
(select max(sequence#) prim_max from v$archived_log where dest_id=1 and archived='YES') p,
(select max(sequence#) fall_max_archived from v$archived_log where standby_dest='YES' and archived='YES' and dest_id=2) f,
(select max(sequence#) dr_max_archived from v$archived_log where standby_dest='YES' and archived='YES' and dest_id=3) d,
(select max(sequence#) fall_max_applied from v$archived_log where standby_dest='YES' and archived='YES' and applied='YES' and dest_id=2) af,
(select max(sequence#) dr_max_applied from v$archived_log where standby_dest='YES' and archived='YES' and applied='YES' and dest_id=3) ad;


select DEST_ID,error from v$archive_dest; 

set pages 100
col ERROR for a15
set lines 2000
col TABLESPACE_NAME form a45
col destination form a50
col error form a30
col type form a10
col HOST_NAME for a20
col EDITION for a10
select INST_ID,INSTANCE_NAME,HOST_NAME,VERSION,STARTUP_TIME,STATUS,PARALLEL,THREAD#,DATABASE_STATUS,INSTANCE_ROLE from  gv$instance;
select  ads.DESTINATION , ads.STATUS, ads.TYPE, ads.ARCHIVED_SEQ#, ads.APPLIED_SEQ#,
a.ARCHIVED_SEQ#-ads.ARCHIVED_SEQ# archive_gap,
decode(ads.APPLIED_SEQ#,0,0,a.ARCHIVED_SEQ#-ads.APPLIED_SEQ#)  applied_gap, ads.ERROR
from v$archive_dest_status ads, (select ARCHIVED_SEQ# from v$archive_dest_status where dest_id=1) a
where status <> 'INACTIVE';

--------------------------------------------ASYNC LGWR--------------------------------
alter system set log_archive_dest_2='service=ICUSTPRD_FB LGWR ASYNC NOAFFIRM delay=0 db_unique_name=ICUSTPRD_NEWFALL compression=enable net_timeout=30 reopen=60 max_failure=3';


-------------------------------Fragmentation --------------------------
select segment_name,to_char(last_analyzed,'DD-MON-YY') last_analyzed,round(bytes/1024/1024,2) "ACTUAL_SIZE",round(avg_row_len*num_rows/1024/1024,2) "RIGHT_SIZE",
round(((bytes/1024/1024)-(avg_row_len*num_rows/1024/1024)*1.1)*100/(bytes/1024/1024),2) "%WASTAGE"
from dba_segments s,dba_tables t
where s.owner=t.owner
and s.segment_name=t.table_name
and s.segment_type='TABLE'
and s.owner='&OWNER'
/
-------------------------------------------   Modify Scheduler job attributs

BEGIN
sys.dbms_scheduler.set_attribute( name => '"PCMSPRD"."RESET_LIMIT"', attribute => 'repeat_interval', value => 'FREQ=WEEKLY;BYDAY=MON,TUE,WED,THU,FRI,SAT,SUN;BYHOUR=6;BYMINUTE=0'); 
sys.dbms_scheduler.set_attribute( name => '"PCMSPRD"."RESET_LIMIT"', attribute => 'start_date', value => systimestamp at time zone '+5:30'); 
END;
-------------------------------------------------------------------------------
1.
BEGIN
   DBMS_STATS.GATHER_FIXED_OBJECTS_STATS;
END;
2.
exec dbms_stats.gather_dictionary_stats();  --
--------------------------------holder for 4 days-------------------------
select * from (
SELECT a.sql_id ,
COUNT(*) OVER (PARTITION BY a.blocking_session,a.user_id ,a.program) cpt,
ROW_NUMBER() OVER (PARTITION BY a.blocking_session,a.user_id ,a.program
order by blocking_session,a.user_id ,a.program ) rn,
a.blocking_session,a.user_id ,a.program, s.sql_text
FROM sys.WRH$_ACTIVE_SESSION_HISTORY a ,sys.wrh$_sqltext s
where a.sql_id=s.sql_id
and blocking_session_serial# <> 0
and a.user_id <> 0
and a.sample_time > sysdate - 3
) where rn = 1
----------------------------------------------Check Number of Blocks corrupted--------


set echo on
select systimestamp
from dual;
select FILE#, BLOCK#, BLOCKS, to_char(NONLOGGED_START_CHANGE#, '999999999999999') NONLOGGED_START_CHANGE#
from v$nonlogged_block;
set pagesize 2000
set linesize 250


SELECT e.owner, e.segment_type, e.segment_name, e.partition_name, c.file#
, greatest(e.block_id, c.block#) corr_start_block#
, least(e.block_id+e.blocks-1, c.block#+c.blocks-1) corr_end_block#
, least(e.block_id+e.blocks-1, c.block#+c.blocks-1)
- greatest(e.block_id, c.block#) + 1 blocks_corrupted
, null description
FROM dba_extents e, v$nonlogged_block c
WHERE e.file_id = c.file#
AND e.block_id <= c.block# + c.blocks - 1
AND e.block_id + e.blocks - 1 >= c.block#
UNION
SELECT null owner, null segment_type, null segment_name, null partition_name, c.file#
, greatest(f.block_id, c.block#) corr_start_block#
, least(f.block_id+f.blocks-1, c.block#+c.blocks-1) corr_end_block#
, least(f.block_id+f.blocks-1, c.block#+c.blocks-1)
- greatest(f.block_id, c.block#) + 1 blocks_corrupted
, 'Free Block' description
FROM dba_free_space f, v$nonlogged_block c
WHERE f.file_id = c.file#
AND f.block_id <= c.block# + c.blocks - 1
AND f.block_id + f.blocks - 1 >= c.block#
order by file#, corr_start_block#;

Size of Segment:-

select OWNER,TABLE_NAME,SEGMENT_NAME,TABLESPACE_NAME,INDEX_NAME from dba_lobs where segment_name in
('SYS_LOB0000072019C00003$$','SYS_LOB0000071994C00006$$','SYS_LOB0000132420C00006$$','SYS_LOB0000071948C00006$$','SYS_LOB0000071991C00008$$');

Table of LOBSEGMENT:--

select OWNER,TABLE_NAME,SEGMENT_NAME,TABLESPACE_NAME,INDEX_NAME from dba_lobs where segment_name in
 ('SYS_LOB0000072019C00003$$','SYS_LOB0000071994C00006$$','SYS_LOB0000132420C00006$$','SYS_LOB0000071948C00006$$','SYS_LOB0000071991C00008$$');
 ---------------------------------------------------------------------------------------------------
TAR UNTAR
tar -cvf dr.tar ./REVERSE_MONITORING_SYNC
if untar ex: go to location /ora11204/orabase ==>   tar -xvf /tmp/oracle.tar
 
RunInstaller
./runInstaller -silent -responsefile /restoration1_new/ora12102db/database/response/db_install.rsp -force -showProgress




kill windows Task
orakill PMSNRI 8764


import export
nohup impdp \"/ as sysdba\" parfile=GCCPROD.par &


----------------Table update------------------------
SELECT SCN_TO_TIMESTAMP(MAX(ora_rowscn)) from myTable
-----------Flush Execution Plan
SQL>  select ADDRESS, HASH_VALUE from GV$SQLAREA where SQL_ID like '';

ADDRESS   HASH_VALUE
---------------- ----------
000000085FD77CF0  808321886

Now we have the address of the handle and hash value of the cursor holding the sql. Flush this from shared pool.

SQL> exec DBMS_SHARED_POOL.PURGE ('000000085FD77CF0, 808321886', 'C');

PL/SQL procedure successfully completed.

SQL>  select ADDRESS, HASH_VALUE from GV$SQLAREA where SQL_ID like '';

no rows selected

--------------------------------------AIX hdisk disk addition------------------------------------------
10.50.55.217
for i in `lspv |grep -i none | awk '{print $1}'`; do echo $i; bootinfo -s $i; lscfg -vpl $i|grep -i Serial; echo ------------------------; done
for i in `lspv| grep -v root | awk '{print $1}'`; do echo $i `lsattr -El $i | grep "reserve_policy"`; done
15:18

cd /dev/ASMDISKS
brw-------    1 root     system       19, 17 Apr 01 18:27 hdisk2  mknod OCR_VOTE_01 c 19 17
brw-------    1 root     system       19,  6 Apr 01 18:27 hdisk3  mknod OCR_VOTE_02 c 9 61
brw-------    1 root     system       19, 13 Apr 01 18:27 hdisk16 mknod OCR_VOTE_03 c 19 13
brw-------    1 root     system       19, 18 Apr 01 18:27 hdisk18 mknod OCR_VOTE_04 c 19 18
brw-------    1 root     system       19, 19 Apr 01 18:27 hdisk17 mknod OCR_VOTE_05 c 19 19
chown -R grid:asmadmin OCR_VOTE_01
chown -R grid:asmadmin OCR_VOTE_02
chown -R grid:asmadmin OCR_VOTE_03
chown -R grid:asmadmin OCR_VOTE_04
chown -R grid:asmadmin OCR_VOTE_05
chmod 660 OCR_VOTE_01
chmod 660 OCR_VOTE_02
chmod 660 OCR_VOTE_03
chmod 660 OCR_VOTE_04
chmod 660 OCR_VOTE_05

-----------------------------------------------------drop tempfile----------------------------------------------
alter database tempfile '/data02/INFREPC2/oradata/data/PROD_2_temp_02.dbf' drop including datafiles;
alter database tempfile '/data1/MXGPROD/oradata/data/PROD_2_LMTEMP_25.dbf' resize 8g;
alter database tempfile '/data1/MXGPROD/oradata/data/PROD_2_LMTEMP_25.dbf' resize 8g;

----------------------create restore point----------------------------------------

Oracle Flashback database and restore points enables us to rewind the database back in time to correct any problems caused by logical data corruption or user errors and it doesn’t require any restoration of backup. There are 2 types of restoration points —

1. Normal Restore Point –> assigns a restore point name to an SCN or specific point in time.The control file stores the name of the restore point and the SCN.

2. Guaranteed Restore Point –> Like Normal restore point, it also serves as an alias for an SCN in recovery operation. The only difference is that the guaranteed restore points never age out of the control file and must be explicitly dropped.


9699009950


11:31:49 SYS@ORCL:1> select name,database_role,open_mode,flashback_on,log_mode from v$database;

NAME      DATABASE_ROLE    OPEN_MODE            FLASHBACK_ON LOG_MODE
--------- ---------------- -------------------- ------------------ ------------
ORCL      PRIMARY          READ WRITE           NO ARCHIVELOG


show parameter recovery

NAME                           TYPE        VALUE

------------------------------ ----------- ----------------------------------------------------------------------------------------------------
db_recovery_file_dest          string      D:\oracle\flashback\orcl
db_recovery_file_dest_size     big integer 2G
recovery_parallelism           integer     0


SELECT NAME, SCN, TIME, DATABASE_INCARNATION#, GUARANTEE_FLASHBACK_DATABASE, STORAGE_SIZE FROM V$RESTORE_POINT WHERE GUARANTEE_FLASHBACK_DATABASE='YES';

no rows selected


CREATE RESTORE POINT SASAMLUS_BEFORE_UPGRADE GUARANTEE FLASHBACK DATABASE;

V$FLASHBACK_DATABASE_LOG –> displays information about the flashback data. Use this view to help estimate the amount of flashback space required for the current workload.

V$FLASHBACK_DATABASE_STAT displays statistics for monitoring the I/O overhead of logging flashback data.

FLASHBACK DATABASE TO RESTORE POINT 'before_upgrade';


-----------------------------------------------------------------------------------------========================

10.50.47.190  oraexa11g  
-----EBA Fallback recovery-------------------
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING ARCHIVED LOGFILE DISCONNECT;



---------------------------------------Restoration Status---------------------------------------------

TTITLE OFF
SET HEAD OFF
SELECT 'Throughput: '||
       ROUND(SUM(v.value/1024/1024),1) || ' Meg so far @ ' ||
       ROUND(SUM(v.value     /1024/1024)/NVL((SELECT MIN(elapsed_seconds)
            FROM v$session_longops
            WHERE opname          LIKE 'RMAN: aggregate input'
              AND sofar           != TOTALWORK
              AND elapsed_seconds IS NOT NULL
       ),SUM(v.value     /1024/1024)),2) || ' Meg/sec'
 FROM gv$sesstat v, v$statname n, gv$session s
WHERE v.statistic# = n.statistic#
  AND n.name       = 'physical write total bytes'
  AND v.sid        = s.sid
  AND v.inst_id    = s.inst_id
  AND s.program LIKE 'rman@%'
GROUP BY n.name
/ 
------------------------------------------Add Disk to Diskgroup--------------------------------------------------------------
PROD
alter diskgroup DATA add disk '/dev/ASM/OAPPROD_DATA06','/dev/ASM/OAPPROD_DATA07','/dev/ASM/OAPPROD_DATA08','/dev/ASM/OAPPROD_DATA09','/dev/ASM/OAPPROD_DATA10' rebalance power 30;

DR
alter diskgroup OAPPROD_DATA add disk '/dev/ASM/OAPPROD_DATA07','/dev/ASM/OAPPROD_DATA08','/dev/ASM/OAPPROD_DATA09','/dev/ASM/OAPPROD_DATA10','/dev/ASM/OAPPROD_DATA11' rebalance power 30;

-------------------unknown file in standby-----------------------------
select file#,NAME,CREATION_TIME from v$datafile where name like '%UNNA%';
alter database create datafile '/oracle/app/oracle/product/10.2.0/db_1/dbs/UNNAMED00536' as '+DATA3/cc/datafile/undotbs9_595_750444337';
Database altered.
----------------------------Drop Asm Diska-------------------------------------
dd if=/dev/zero of=<device name> bs=1024k count=100 

You will replace <device name> with the path and name of each disk (/dev/ASM/OAPPROD_DATA06, for example). Once that is complete, these disks will then show as candidate disks. 
 kfod status=TRUE asm_diskstring=' /dev/ASM/*' disks=ALL
 -------------------------Register Logfile------------------
alter database register logfile '/amlibgtm_arch/AMLIBGTM/arch/AMLIBGTM1_793465702_297969.arc'
************************************ Cursor sharing exact*************************************
select /*+ cursor_sharing_exact */
------------------------------------expdp------------------------------
expdp username/password DIRECTORY=DATA_PUMP_DIR DUMPFILE=TBL_TRANSACTIONS_%u.dmp tables=TBL_TRANSACTIONS reuse_dumpfiles=yes query='tbl_transactions:"where
transactiondatetime  between to_date('13-jul-2019','dd-mon-yyyy') and to_date('02-aug-2019','dd-mon-yyyy')"'

---------------

disk details --- query 


col PATH for a40
set lines 400 pages 400
select group_number,disk_number,name,path,header_status,os_mb/1024 os_gb from v$asm_disk order by 3;

------------------------Move datafile / Rename datafile --------------------
$ mv EZYPAYCL_UNDOTBS_02* /eazypayData8/db_file												  
run
{
set newname for datafile 6 to '/eazypayData1/ezypaycl/oradata/data/EZYPAYCL_UNDOTBS_02.dbf';
restore datafile 6;
}

switch datafile 6 to copy;
switch datafile 6 to copy;
----------------------------------access to dynamic views-------------------------------------------------------------
SQL> grant select_catalog_role to GEMSPROD;

Grant succeeded.
-----------------------CRON-- for every 2nd and 4th saturday--------------------------------
00 9 8-14,22-28 * * [ `date +\%u` = 6 ] && ksh -x /ora12102/orabase/oracle/maint/cron/ICUSTPRD_ICUSTADM_STAT.sh

-----------------------CRON -- For every 1st and 3rd saturday

00 9 8-14,22-28 * * [ `date +\%u` = 1 ] && ksh -x /ora12102/orabase/oracle/maint/cron/ICUSTPRD_ICUSTADM_STAT.sh

------------------------------
1. First check what datapump jobs are running:
SQL> select * from dba_datapump_jobs;
OWNER_NAME  JOB_NAME              OPERATION   JOB_MODE   STATE      DEGREE ATTACHED_SESSIONS
------------------------------ ------------------------------ ------------------------------ 
SYSTEM      SYS_EXPORT_FULL_01    EXPORT        FULL   EXECUTING     32         1
2. To stop/kill the datapump job, login as sysdba and execute from sqlplus:
DECLARE
   h1 NUMBER;
BEGIN
   h1 := DBMS_DATAPUMP.ATTACH('JOB_NAME','OWNER_NAME');
   DBMS_DATAPUMP.STOP_JOB (h1,1,0);
END;
/
---------------------------User ownership-----------------------
 logins -xml ora12102
---------------- network root ---------------
 traceroute pfmsprod-scan
 --------------------------list tag-----
 
 select listagg(COLUMN_NAME,' ') within group (order by COLUMN_NAME)  from dba_tab_columns  where HISTOGRAM !='NONE' and TABLE_NAME='DYNA_CACHE_TABLE';
 
 exec DBMS_STATS.GATHER_TABLE_STATS('CRPADM','DYNA_CACHE_TABLE', DEGREE=>3, estimate_percent=> dbms_stats.auto_sample,CASCADE=>TRUE,method_opt=>'FOR ALL COLUMNS SIZE REPEAT');
 
 
=======================================================Locked objects============
SELECT O.OBJECT_NAME, S.SID, S.SERIAL#, P.SPID, S.PROGRAM,S.USERNAME,
S.MACHINE,S.PORT , S.LOGON_TIME,SQ.SQL_FULLTEXT 
FROM V$LOCKED_OBJECT L, DBA_OBJECTS O, V$SESSION S, 
V$PROCESS P, V$SQL SQ 
WHERE L.OBJECT_ID = O.OBJECT_ID 
AND L.SESSION_ID = S.SID AND S.PADDR = P.ADDR 
AND S.SQL_ADDRESS = SQ.ADDRESS
and OBJECT_NAME='&object_name';
===============================================Objects DDL===================================
set longc 3999 long 999999
select TO_CHAR(dbms_metadata.get_ddl('&OBJECT_TYPE','&OBJECT_NAME','&OWNER')) from dual;
SELECT DBMS_METADATA.get_ddl ('DB_LINK','&name','&owner') from dual;
=============================================================================================

  CREATE DATABASE LINK "SMTABLET"
   CONNECT TO "SMTABLET" IDENTIFIED BY VALUES ':1'
   USING '(DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 172.16.14.44)(PORT = 4896)))
    (CONNECT_DATA =
      (SID = SMTABLET))
    (HS=OK))'

===============================================

inventory location- cat /var/opt/oracle/oraInst.loc   solaris
inventory location- cat /etc/oraInst.loc   AIX,LINUX

-------------------------
ORA-600/ORA-7445/ORA-700 Error Look-up Tool
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=537517814737120&id=153788.1&_adf.ctrl-state=3seniq9wp_48

-----------------------------------Resize datafile----------------------------------------
ALTER DATABASE DATAFILE '/u02/oracle/rbdb1/stuff01.dbf' RESIZE 100M;
ALTER DATABASE DATAFILE 123 RESIZE 100M;
------STANDBY CREATtion-------------------------------------------------------------------
nohup rman TARGET sys/dba_ic09@SFMSNEW_DR AUXILIARY sys/dba_ic09@SFMSNEW_NEWDR cmdfile=duplicate.cmd log=log.log &
run
{
DUPLICATE TARGET DATABASE FOR STANDBY FROM ACTIVE DATABASE NOFILENAMECHECK;
}
----------------------------------------Brows Net backup--------------------------------------------------
/usr/openv/netbackup/bin/bplist -C  EXD2DBADM04  -k IB-553-EXD2DBADM04-RMAN-AMLTMUAT2-FULL-ONETIME-25092019-UAT  -t 4 -R  -s 10/01/2019  -e  10/02/2019  -l /
---------------------------------------------------NetBackup-------------------------------------------------------
[ora11gdb@IHYDP780-02-LP1]/ora11gdb/oracle/OraHome1>cd /usr/openv/netbackup/bin
[ora11gdb@IHYDP780-02-LP1]/usr/openv/netbackup/bin>sbttest test
The sbt function pointers are loaded from libobk.a(shr.o) library.
-- sbtinit succeeded
-- sbtinit (2nd time) succeeded
sbtinit: Media manager supports SBT API version 2.0
sbtinit: Media manager is version 5.0.0.0
sbtinit: vendor description string=Veritas NetBackup for Oracle - Release 7.5 (2013061101)
sbtinit: allocated sbt context area of 8 bytes
sbtinit: proxy copy is supported
-- sbtinit2 succeeded
-- regular_backup_restore starts ................................


ln -s /usr/openv/netbackup/bin/libobk.so.1 libobk.so
------------------------------------- oratab----------------------------------------------------------------------------------
Linux		/etc/oratab
Solaris		/var/opt/oracle/oratab
IBM AIX		/etc/oratab


--------------------Locked objects----------------------------
select a.ORACLE_USERNAME,a.SESSION_ID,b.OBJECT_NAME,b.OBJECT_TYPE,a.LOCKED_MODE from V$LOCKED_OBJECT a,dba_objects b where a.OBJECT_ID=b.OBJECT_ID


select
   c.owner,
   c.object_name,
   c.object_type,
   b.sid,
   b.serial#,
   b.status,
   b.osuser,
   b.machine
from
v$locked_object a ,
   v$session b,
   dba_objects c
where
   b.sid = a.session_id
and
   a.object_id = c.object_id;


--------------------------------Past Blocking session---
dba_hist_active_sess_history
---------------------------------- Long running more than 2 hour--------------------------
select a.SID, a.SERIAL#,a.SQL_ID,a.LOGON_TIME,b.sql_text from v$session a, v$sql b  where to_char(logon_time,'dd-mon-yyyy hh24:mi') < '25-Oct-2019 18:00' and
a.sql_id=b.sql_id and 
 a.SQL_ID is not null;
--------------------------------------Open cursor----------------------------------------------------------
select max(a.value) as highest_open_cur, p.value as max_open_cur
from v$sesstat a, v$statname b, v$parameter p
where a.statistic# = b.statistic#
and b.name = 'opened cursors current'
and p.name= 'open_cursors'
group by p.value;


Open cursor

col sid for 9999
col user_name for a30
col sql_id for a30
select  user_name,sql_id,sql_text, count(*) as "OPEN CURSORS", user_name from v$open_cursor
group by user_name,sql_id,sql_text order by count(*) ASC;


select  user_name,count(*) as "OPEN CURSORS", user_name from v$open_cursor
group by user_name order by count(*) ASC;


------------------------Previous blocking session--------dba_hist_active_sess_history--------------------------
select
   sql_id,
   event,
   count(*),
   lpad(round(ratio_to_report(count(*)) over () * 100)||'%',10,' ') percent
from
   dba_hist_active_sess_history
where
   sample_time between timestamp '2013-07-20 11:00:00'
and
   timestamp '2013-07-20 12:00:00'
and
   event = 'enq: TX - allocate ITL entry'
group by
   sql_id, event
order by
   percent desc;

---------------------------Purge Recycle Bin-----------------------------
select 'purge table '||owner||'."'||OBJECT_NAME||'";' 
from dba_recyclebin where 
to_date(droptime,'YYYY-MM-DD:HH24:MI:SS')<sysdate-(1);

select b.name,a.OWNER,count(*),sum(a.SPACE)*8/1024 "MB" from dba_recyclebin a , v$database b group by a.OWNER,b.name;

select b.name,a.OWNER,count(*),sum(a.SPACE)*8/1024 "MB" from dba_recyclebin a , v$database b where to_date(a.droptime,'YYYY-MM-DD:HH24:MI:SS')<sysdate-(30) group by a.OWNER,b.name;
-------------------------------------planc----------------------------------
set lines 155
col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a30
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id, ss.instance_number node, begin_interval_time, sql_id, plan_hash_value,
nvl(executions_delta,0) execs,
(elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime,
(buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio,
(rows_processed_delta/decode(nvl(rows_processed_delta,0),0,1,executions_delta)) avg_row
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = nvl('&sql_id','4dqs2k5tynk61')
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
--and executions_delta > 0
order by 1, 2, 3
/


Belo w
SELECT s.sql_id,sn.begin_interval_time,s.plan_hash_value,count(*) AS Count
FROM dba_hist_sqlstat s
, dba_hist_snapshot sn 
WHERE s.snap_id = sn.snap_id
AND s.sql_id = '&your_sql_id' 
AND sn.begin_interval_time > SYSDATE - 7 -- Last 7 days, adjust as needed
GROUP BY s.sql_id,sn.begin_interval_time,s.plan_hash_value
UNION ALL
select distinct(sql_id),sample_time,sql_plan_hash_value AS PLAN_HASH_VALUE,count(*) AS Count
from gv$active_session_history 
where sql_id='&your_sql_id'
and sample_time > SYSDATE-7 -- Last 7 days, adjust as needed
 group by sql_id,sql_plan_hash_value,sample_time 
 order by 1,2;
 
 
 
 select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime,
abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='&sql_id' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;


--------------------------------plana------------------------
select * from table(dbms_xplan.display_awr('&sql_id',null));
SQL> select * from table(dbms_xplan.display_cursor('&sql_id',null));
 select * from table(dbms_xplan.display_cursor('&sql_id',null));


Ø  Select plan for
Select * from …                                             -----------Copy your query
Ø  Select * from table(dbms_xplan.display);


positive

--------------------------------------------------sqls Current Plan---------------------
set lines 200 pages 5000
col sql_Text for a40
select inst_id,sql_id, sql_text, plan_hash_value, executions, (elapsed_time/executions)/1000000 avg_time_sec,
 buffer_gets/executions avg_lio,SQL_PROFILE,
 rows_processed/executions avg_row
from gv$sqlarea
where sql_id='&sql_id' ;
-------------------------sqlnet.ora---------------------------------
SQLNET.ALLOWED_LOGON_VERSION=8
SQLNET.ALLOWED_LOGON_VERSION_SERVER=8
SQLNET.ALLOWED_LOGON_VERSION_CLIENT=8
==========================================
login with tns entry for sys
SQLNET.AUTHENTICATION_SERVICES = (NTS)
###SQLNET.AUTHENTICATION_SERVICES = (NONE)
SQLNET.ALLOWED_LOGON_VERSION_SERVER=8

SQLNET.SEND_TIMEOUT=600
WALLET_LOCATION =
   (SOURCE =
     (METHOD = FILE)
     (METHOD_DATA =
       (DIRECTORY = /RRAPPLICATION/OW)
     )
   )
#SQLNET.WALLET_OVERRIDE = FALSE
##SQLNET.WALLET_OVERRIDE = FALSE
SQLNET.WALLET_OVERRIDE = TRUE
##SQLNET.WALLET_OVERRIDE = FALSE
SSL_CLIENT_AUTHENTICATION =TRUE
SSL_VERSION = 0
SQLNET.ALLOWED_LOGON_VERSION_SERVER=8
SQLNET.ALLOWED_LOGON_VERSION_CLIENT=8



1 TB 
1 freee/usage

2

3



---------------------------------DB growth--------------------------
SELECT ts# FROM v$tablespace where name = '&v_ts_name';
SELECT block_size FROM dba_tablespaces where tablespace_name = '&v_ts_name';
SELECT min(snap_id), max(snap_id), min(trunc(to_date(rtime,'MM/DD/YYYY HH24:MI:SS'))), max(trunc(to_date(rtime,'MM/DD/YYYY HH24:MI:SS'))) from dba_hist_tbspc_space_usage where tablespace_id=&v_ts_id and  (to_date(rtime,'MM/DD/YYYY HH24:MI:SS') > (sysdate - 31));
SELECT round(max(tablespace_usedsize)*8192/1024/1024,2) from dba_hist_tbspc_space_usage where tablespace_id=&v_ts_id and snap_id = &v_begin_snap_id;
SELECT round(max(tablespace_usedsize)*8192/1024/1024,2) from dba_hist_tbspc_space_usage where tablespace_id=&v_ts_id and snap_id = &v_end_snap_id;
----------------------------------------get plan-------
 set autotrace TRACEONLY
--------------------------source d1-
XSELLPRD
---------------------------------------------
column dt new_val X
select to_char(sysdate,'yyyymmdd') dt from dual;
spool UPI_TRANLOG_&X._Anal.txt
----------------------------- Flush Plan-------
SQL> select ADDRESS, HASH_VALUE, plan_hash_value from V$SQLAREA where SQL_ID='&sql';

ADDRESS          HASH_VALUE
---------------- ----------
000000085FD77CF0  808321886
exec DBMS_SHARED_POOL.PURGE ('000000085FD77CF0, 808321886', 'C');


--------------------------------Auto Extend----------------------------------------------------------
select file_name,tablespace_name,bytes/1024,AUTOEXTENSIBLE,status from dba_data_files order by tablespace_name;
-----------------Temp Size------------
select TABLESPACE_NAME, sum(BYTES_USED/1024/1024),sum(BYTES_FREE/1024/1024) from V$TEMP_SPACE_HEADER group by TABLESPACE_NAME;	
SELECT * FROM dba_temp_free_space;
------------------------------------
Gather disctionary as below:
exec dbms_stats.gather_fixed_objects_stats;
exec dbms_stats.gather_system_stats;
exec dbms_stats.gather_dictionary_stats;
-----------------------------------Partition table stat copy-----------------

exec dbms_stats.copy_table_stats('IPSLIVE','COM_FC_DOWNLOAD_PROCESS_TMP',srcpartname=>'SYS_P80376',dstpartname=>'SYS_P81482');

------------------------------------------------Temp usage-------------------------------------------------------------------------------
select distinct
c.username "user",
c.osuser ,
c.sid,
c.serial#,
b.spid "unix_pid",
c.machine,
c.program "program",
a.blocks * e.block_size/1024/1024 mb_temp_used  ,
a.tablespace,
d.sql_text
from
v$sort_usage a,
v$process b,
v$session c,
v$sqlarea d,
dba_tablespaces e
where c.saddr=a.session_addr
and b.addr=c.paddr
and c.sql_address=d.address(+)
and a.tablespace = e.tablespace_name;
---------------------------------------EXPDP \ IMPDP  --------------
nohup impdp \"/ as sysdba\" full=Y directory=imp dumpfile=mxg_%U.dmp logfile=mxg_dec10.log parallel=20 table_exists_action=replace
---------------------------------------------------------

chmod u+r /ora12102/orabase/oracle/lib/libsqlplus.so

---------------Drop standby logfile----------------
alter database drop standby logfile group &i;
alter database drop  logfile group &i;
-------------------------------ACTIVITY---------------------
STAT Gather   :-	exec DBMS_STATS.GATHER_TABLE_STATS('owner','table_name', DEGREE=>As_PER_CPU, estimate_percent=>100,CASCADE=>TRUE,method_opt=>'FOR ALL COLUMNS SIZE REPEAT');
INDEX Rebuild :- 	alter index owner.index_name rebuild parallel(degree As_PER_CPU);
Reorg 		  :- 	alter table owner.segment_name move tablespace tablespace_name parallel As_PER_CPU;

exec dbms_stats.gather_fixed_objects_stats;
exec dbms_stats.gather_system_stats;
exec dbms_stats.gather_dictionary_stats;

Select * from sys.aux_Stats$;
-------------------------------------------------------------

latch: ges resource hash list
enq: TX - index contention 
 buffer busy waits
-------------------Windows Patch ----------------------
SET PERL5LIB=
set PATH=c:\windows\system32;%ORACLE_HOME%\perl\bin;%ORACLE_HOME%\bin;%PATH%
-----------------------------------------FTS full table scan------------------
col c1 heading ‘Begin|Interval|time’ format a20
col c4 heading ‘Full table scan|Count’  format 999,999
break on c1 skip 2
break on c2 skip 2
select
  to_char(sn.begin_interval_time,'yy-mm-dd hh24')  c1,
  count(1)                                         c4
from
   dba_hist_sql_plan p,
   dba_hist_sqlstat   s,
   dba_hist_snapshot sn,
   dba_segments      o
where
   p.object_owner <> 'SYS'
and
   p.object_owner = o.owner 
and
   p.object_name = o.segment_name 
and
   o.blocks > 1000
and
   p.operation like '%TABLE ACCESS%'
and
   p.options like '%FULL%'
and
   p.sql_id = s.sql_id
and
   s.snap_id = sn.snap_id  
group by
  to_char(sn.begin_interval_time,'yy-mm-dd hh24')
order by
  1;
  ---------------------------Check version -----------
  pkg info entire
  ----------------
  select SERVERIP,NAME,RESOURCE_NAME,INITIAL_ALLOCATION,SUM as SUM_MAX_UTLZ,(INITIAL_ALLOCATION - SUM ) DIFF_MAX_UTLZ ,SUM_CUR_UTLZ,(INITIAL_ALLOCATION - SUM_CUR_UTLZ) DIFF_CUR_UTLZ from
 ( select SERVERIP,NAME,RESOURCE_NAME,INITIAL_ALLOCATION,sum(MAX_UTILIZATION) as SUM,sum(CURRENT_UTILIZATION) SUM_CUR_UTLZ  from AUTO_DB_PROCESS_DETAILS group by SERVERIP,NAME,RESOURCE_NAME,INITIAL_ALLOCATION
  ) where (INITIAL_ALLOCATION - SUM ) < 0 order by (INITIAL_ALLOCATION - SUM ) ;

  ----------------- Kill inactive session where inactive more than 10min
  select 'ALTER SYSTEM KILL SESSION '||''''||sid||','||serial#||',@'||inst_id||''''||' immediate;' from 
(select username,status,sid,serial#,LAST_CALL_ET,inst_id,count(*) over () insess from gv$session where status = 'INACTIVE' and username ='DCMICICI' and type<>'BACKGROUND')
where insess > 500 and LAST_CALL_ET > 10*60;

------------------------Explain Plan---------------------SQL> explain plan for
  2  Select TXNH.TXN_STATUS,TXNH.REQ_ID, TXND.EXTERNAL_REF_NO, TXND.HOST_REF_NO,TXND.ENTRY_RMKS,TXNH.TXN_ID,
TXND.NETWORK_ID from crpadm.TXNH,crpadm.TXND where TXNH.BANK_ID = 'ICI' AND TXNH.CORP_ID = UPPER('ICICIBAN07022020NOD')
AND TXNH.CORP_USER = UPPER('TERENCEO') AND TXNH.TXN_ID = TXND.TXN_ID AND TXNH.R_CRE_TIME >= '2020-03-12 00:00:00.0'
AND TXNH.R_CRE_TIME < '2020-03-16 00:00:00.0'
AND TXNH.TXN_TYPE IN ( 'PMT' ,  'PWT' ) AND TXNH.FILE_UPLOAD_NUM IS NULL;  3    4    5    6

Explained.

SQL> select * from table(dbms_xplan.displaY);

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Plan hash value: 2557258487

--------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                | Name                | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
--------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |                     |     1 |   157 |     2   (0)| 00:00:01 |       |       |
|*  1 |  FILTER |                     |       |       |            | |       |       |
|   2 |   NESTED LOOPS |                     |     1 |   157 |     2   (0)| 00:00:01 |       |       |
|   3 |    NESTED LOOPS |                     |     1 |   157 |     2   (0)| 00:00:01 |       |       |
|   4 |     PARTITION HASH ALL |                     |     1 |    90 |     1   (0)| 00:00:01 |     1 |    16 |
|   5 |      INLIST ITERATOR |                     |       |       |            | |       |       |
|*  6 |       TABLE ACCESS BY INDEX ROWID BATCHED| TRANSACTION_HEADER  |     1 |    90 |     1   (0)| 00:00:01 |       |       |
|*  7 |        INDEX RANGE SCAN                  | IDX_TXN_DET         |     1 |       |     1   (0)| 00:00:01 | 1 |    16 |
|   8 |     PARTITION HASH ALL |                     |     1 |       |     1   (0)| 00:00:01 |     1 |     4 |
|*  9 |      INDEX RANGE SCAN                    | IDX_TXND_TXNSTAT    |     1 |       |     1   (0)| 00:00:01 | 1 |     4 |
|  10 |    TABLE ACCESS BY INDEX ROWID           | TRANSACTION_DETAILS |     1 |    67 |     1   (0)| 00:00:01 |       |       |
--------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter(TO_DATE('2020-03-16 00:00:00.0')>TO_DATE('2020-03-12 00:00:00.0'))
   6 - filter("TXNH"."FILE_UPLOAD_NUM" IS NULL AND "TXNH"."R_CRE_TIME">='2020-03-12 00:00:00.0' AND
              "TXNH"."R_CRE_TIME"<'2020-03-16 00:00:00.0' AND "TXNH"."BANK_ID"=U'ICI')
   7 - access("TXNH"."CORP_ID"=U'ICICIBAN07022020NOD' AND "TXNH"."CORP_USER"=U'TERENCEO' AND ("TXNH"."TXN_TYPE"=U'PMT'
              OR "TXNH"."TXN_TYPE"=U'PWT'))
   9 - access("TXNH"."TXN_ID"="TXND"."TXN_ID")

27 rows selected.

---------------------------------------------IOCP-----------------------------------------------------------------------------
{IHYDIBMPF-C1B4-CL5} /ora11204 $ lsdev|grep iocp
iocp0           Available             I/O Completion Ports
{IHYDIBMPF-C1B4-CL5} /ora11204 $ uname
AIX
{IHYDIBMPF-C1B4-CL5} /ora11204 $
------------------create listener------------
tnsnames.ora
SDTDB =
   (ADDRESS_LIST =
        (ADDRESS = (PROTOCOL = TCP)(HOST =10.113.244.26)(PORT = 9081))
   )
SID_LIST_SDTDB=
   (SID_DESC =
      (ORACLE_HOME =/oracle/app/product/11204)
      (SID_NAME =SDTDB )
   )  
tnsnames.ora
SDTDB = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 10.113.244.26)(PORT = 9081))) (CONNECT_DATA = (SERVICE_NAME = SDTDB)))
--------------------------------------------Solaris shm----------------------------------------------
prctl -n project.max-shm-memory -i process $$
-----------------------------------------

cron for purge------------
00 00 * * * ksh /DBHOME/maint/purge/trace_purge.sh
{ihydibme850-13-cl9} /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/sqlwork $ cat /DBHOME/maint/purge/trace_purge.sh

/usr/bin/find /oradumps/diag/rdbms/bbpsprod/BBPSPROD1/alert -name "*.xml" -mtime +7 -exec /usr/bin/rm  {} \;
/usr/bin/find /oradumps/diag/rdbms/bbpsprod/BBPSPROD1/trace -name "*.trc" -mtime +15 -exec /usr/bin/rm  {} \;
/usr/bin/find /oradumps/diag/rdbms/bbpsprod/BBPSPROD1/trace -name "*.trm" -mtime +15 -exec /usr/bin/rm  {} \;
/usr/bin/find /oradumps/diag/rdbms/bbpsprod/BBPSPROD1/cdump -name "*core" -mtime +7 -exec /usr/bin/rm  {} \;
/usr/bin/find /oradumps/diag/rdbms/bbpsprod/BBPSPROD1/incident -name "*inc" -mtime +7 -exec /usr/bin/rm  {} \;
/usr/bin/find /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/rdbms/audit -name "*.aud" -mtime +15 -exec rm {} \;

{ihydibme850-13-cl9} /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/sqlwork $

--------------------- Time out ------------
netstat -na|grep -i TIME_WAIT

============================================
SQL> alter database clear logfile group 21;
alter database clear logfile group 21
*
ERROR at line 1:
ORA-00350: log 21 of instance FCRM10DB (thread 1) needs to be archived
ORA-00312: online log 21 thread 1: '/fcrmredo01/FCRM10DB/log/FCRM10DB_STANDBY_REDO_21A.LOG'


SQL> alter database clear unarchived logfile group 21;

Database altered.

SQL> alter database drop standby logfile group 21;
holder
Database altered.

SQL>
================================================orapwd password file
orapwd file=orapwDQMMISDB password=Tig_ic21 force=y entries=40 ignorecase=Y
========================================================
Find below jdbc url,

datasource.url=jdbc:oracle:thin:@//10.50.60.xxx:9070/DB
db_url=jdbc:oracle:thin:@//cgtma2dbv01cn.gms.netcracker.com:1521/CGTMA2
======================================ONS===================
Mankali Anil      /EXT/TCCTI_DEPT/IBANK/HYD
$ORACLE_HOME/opmn/bin/onsctl debug
from grid


===================================free.sql=========================
column free_space format 999999999
column used_space format 999999999
column total_space format 9999999999
set linesize 132
column "Tablespace Name" format a30
SELECT Total.name "Tablespace Name",
         Free_space, (total_space-Free_space) Used_space, total_space, Max_Mb
  ,free_space/total_space*100 perc
  FROM
    (select tablespace_name, sum(bytes/1024/1024) Free_Space, max(bytes/1024/1024) MAx_mb
       from sys.dba_free_space
      group by tablespace_name
    ) Free,
    (select b.name,  sum(bytes/1024/1024) TOTAL_SPACE
       from sys.v_$datafile a, sys.v_$tablespace B
      where a.ts# = b.ts#
      group by b.name
    ) Total
  WHERE Free.Tablespace_name(+) = Total.name
 order by perc ;
 ====================================================
 

bash-4.3# schedo -L| grep "vpm_xvcpus" |cut -d " " -f 17

0

bash-4.3#

bash-4.3# schedo -o vpm_xvcpus=2 Setting vpm_xvcpus to 2

bash-4.3#

bash-4.3# schedo -L| grep "vpm_xvcpus" |cut -d " " -f 17

2

bash-4.3#
=============================== ps -ef |grep=================
 ps -ef  |grep "dr_report" | awk {'print $2'} | xargs kill -9
======================================= Heap Size ======================
select
nam.ksppinm NAME,
nam.ksppdesc DESCRIPTION,
val.KSPPSTVL
from
x$ksppi nam,
x$ksppsv val
where nam.indx = val.indx and nam.ksppinm like '%kgl_large_heap_%_threshold%';
=================================
=================================
=================================
=================================
=================================
=================================
=================================
=================================UnderScore Parameter =======
col name for A45
set lines 120
col value for A40
set pagesize 100
select name, value from v$parameter where name like '\_%' escape '\';

select 
ksppinm,
ksppdesc 
from 
x$ksppi
where 
substr(ksppinm,1,1) = '_';
========================================== Temp Usage===========================
SQL> select  tu.username,s.sid,s.serial# from v$tempseg_usage tu, v$session s where tu.session_addr=s.saddr;

============ free.sql with recycle_bin object =========
with ts as
 (select name,blocksize,ts#,bitmapped from ts$)
 select /*+ RULE */ a.name "Tablespace Name",total "Total Space",total-free "Used Space",free "Free Space",(free/total)*100 "% Free" from
 (select
 ts.name,
 sum(f.length * ts.blocksize/1024/1024) free
 from ts,sys.fet$ f
 where ts.ts# = f.ts#
 and ts.bitmapped = 0
 group by ts.name
 )a,
 (select ts.name,
 sum((ts.blocksize * f.blocks)/1024/1024) Total
 from sys.file$ f,ts
 where f.ts# = ts.ts#
 and bitmapped=0
 group by ts.name
 )b
 where a.name=b.name
 union all
 SELECT name,Total,total-free,free,(free/total)*100 "% used" from
 (select name,
 sum(round(KTFBHCSZ*blocksize/1024/1024/1024,2)) total,
 sum(round(KTFBHCFREE*blocksize/1024/1024/1024,2)) free
 FROM x$ktfbhc,ts where ts#=KTFBHCTSN
 group by name )order by 5; 

 ==================================Insert Operation ===
  select sum(INSERTS),sum(UPDATES),sum(DELETES),to_char(TIMESTAMP,'yy-mm-dd hh24') from DBA_TAB_MODIFICATIONS 
  where TIMESTAMP > sysdate -3 group by to_char(TIMESTAMP,'yy-mm-dd hh24') order by  to_char(TIMESTAMP,'yy-mm-dd hh24');
  ==============Index monitoring===
  SELECT index_name,table_name,monitoring,used,start_monitoring,end_monitoring FROM   v$object_usage
WHERE  index_name ='IX_WLI_QS_REPORT_ATTRIBUTE_IED' and TABLE_NAME='WLI_QS_REPORT_ATTRIBUTE';
====================
chmod 7651 oracle
/DBHOME/oracle
 chgrp asmadmin /DBHOME/oracle/app/oracle/product/12.1.0.2/dbhome_1/bin/oracle
========================
C:\Users\oradba>oradim -new -sid SFMSNEW
Instance created.
C:\Users\oradba>sqlplus -version
SQL*Plus: Release 19.0.0.0.0 - Production
Version 19.3.0.0.0
===================================oracle ownership==============
su - grid
cd <Grid Home>/bin
./setasmgidwrap o=[RDBMS Home]/bin/oracle
===========================================redo multiplexinf ===================
ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 GROUP 10 ('/u01/app/oracle/oradata/DB11G/standby_redo01.log') SIZE 50M;
ALTER DATABASE ADD LOGFILE THREAD 2 GROUP 5 ('+REDO1','+REDO2') SIZE 1G;
ALTER DATABASE DROP LOGFILE MEMBER '/oracle/dbs/log3c.rdo';
ALTER DATABASE ADD LOGFILE member '/oracle/oradata/CURACAO9/redo03b.log' reuse to GROUP 3;

alter database drop logfile group &1;
=================
alter database create datafile 1133 as '+DATA' size 8g;
alter system set standby_file_management=AUTO scope=both;


SQL> alter database drop logfile group &1;
Enter value for 1: 3
old   1: alter database drop logfile group &1
new   1: alter database drop logfile group 3
alter database drop logfile group 3
*
ERROR at line 1:
ORA-01623: log 3 is current log for instance cgrba4 (thread 1) - cannot drop
ORA-00312: online log 3 thread 1: '+RB_REDOA/CGRBA4/onlinelog/group_3.272.1090149805'


=========================User$=============
SELECT NAME, type#, ctime, ptime, exptime, ltime, lcount 
  FROM sys.user$
WHERE NAME IN ('&name')  
ORDER BY NAME;
NAME – name for user or role
TYPE# – 0 for role or 1 for user
CTIME – the date of creation
PTIME – the date the password was last changed
EXPTIME – the date the password has last expired
LTIME – the date the resource was last locked
LCOUNT – number of failed logon
======================= attatch oracle home to inventory====== 
./runInstaller -silent -ignoreSysPrereqs -attachHome ORACLE_HOME="/DBHOME/oracle/app/oracle/product/12.1.0.2/dbhome_1" ORACLE_HOME_NAME="ORA12102_ORACLE"
=====Modify local listener port ===
srvctl modify scan_listener -p TCP:1523
srvctl modify listener -l LISTENER -p 1721

standby duplicate =====================
nohup rman target sys/dba_ic09@CIBNXPRD_JPR auxiliary sys/dba_ic09@CIBNXPRD_NEW_DR cmdfile=duplicate.cmd log=duplicate.log &
RMAN> connect TARGET sys / sys @ AMAR;   ## Target database ##
connected to target database: AMAR (DBID=1450838187) 

RMAN> connect AUXILIARY sys / sys @ TEST ;  ## Auxiliary database ##
connected to auxiliary database: TEST (not mounted) 

RMAN> connect CATALOG rman / rman @ CAT ; ## Catalog database .Optional ## 
connected to recovery catalog database
=============================Install Database Component ===
Installing Oracle Text
https://docs.oracle.com/database/121/DFSIG/oracle-text.htm#DFSIG269
@$ORACLE_HOME/ctx/admin/catctx.sql CTXSYS SYSAUX LMTEMP NOLOCK;
connect CTXSYS/CTXSYS
@$ORACLE_HOME/ctx/admin/defaults/drdefus.sql;
SQL> grant execute on UTL_HTTP to ctxsys;
Grant succeeded.
SQL> alter package ctxsys.drvdml compile body;
Package body altered.
SQL> EXECUTE SYS.VALIDATE_CONTEXT;
PL/SQL procedure successfully completed.
SQL> select status from dba_registry;

Oracle XDK: - 	How to remove and reinstall the XDK in Oracle 12 (Doc ID 2470780.1)
@?/xdk/admin/initxml.sql
=============================================
bash-4.3# lsdev | grep -i iocp

iocp0       Available             I/O Completion Ports

###################################################



$ORACLE_HOME\ctx/admin/defaults/drdefus.sql;


====================================ORACLE PERMISSION======================
{ihydibme850-04-cl3} /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/bin $ ls -llt oracle
-rwxr-x--x    1 ora12102 asmadmin  548997761 Feb 18 05:39 oracle

{ihydibme850-03-cl2} /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/bin $ ls -llt oracle
-rwsr-s--x    1 ora12102 asmadmin  548997761 Apr 15 2020  oracle
 
{ihydibme850-04-cl3} /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/bin $ chmod 6751 oracle

{ihydibme850-04-cl3} /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/bin $ ls -llt oracle

-rwsr-s--x    1 ora12102 asmadmin  548997761 Feb 18 05:39 oracle

 
###############################RAC MANAULLY PATCHING #################
 Manual patching of Oracle RAC Server:-
Run the pre root script.

% $ORACLE_HOME/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -phBaseDir /tmp/PSU_PATCH/31305339/31281355
% $ORACLE_HOME/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -phBaseDir /tmp/PSU_PATCH/31305339/31305087
% $ORACLE_HOME/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -phBaseDir /tmp/PSU_PATCH/31305339/31304218
% $ORACLE_HOME/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -phBaseDir /tmp/PSU_PATCH/31305339/31335188

If this is a GI Home, as the root user execute:
1.#/GRIDHOME/app/19.3.0/grid/crs/install/rootcrs.sh -prepatch

This will shut down CRS & its resources
Make sure that nothing is running from grid User

2.    Patch GI home.
As the GI home owner execute:
cd /GRIDHOME/app/19.3.0/grid/OPatch

$ ./opatch apply -oh /GRIDHOME/app/19.3.0/grid -local /tmp/PSU_PATCH/31305339/31281355
$ ./opatch apply -oh /GRIDHOME/app/19.3.0/grid -local /tmp/PSU_PATCH/31305339/31305087
$ ./opatch apply -oh /GRIDHOME/app/19.3.0/grid -local /tmp/PSU_PATCH/31305339/31304218
$ ./opatch apply -oh /GRIDHOME/app/19.3.0/grid -local /tmp/PSU_PATCH/31305339/31335188


4.    Run the post script.
As the root user execute:
#/GRIDHOME/app/19.3.0/grid/rdbms/install/rootadd_rdbms.sh

5.   If this is a GI Home, as the root user execute:
#/GRIDHOME/app/19.3.0/grid/crs/install/rootcrs.sh -postpatch
######################################################################





===================== Explain Plan =======
You can get query execution plan at your end by using below command.

> explain plan for  

<paste your query>

>select * from table(dbms_xplan.display);

####################################################IMPDP/EXPDP####################
Points to remember while Performing export/import :
1. Create Directort :- Create  directory physically at OS level and logically at database level with the help of sysdba team .
2. Get required privilege to perform import/export :That database user performing the export will need DATAPUMP_EXP_FULL_DATABASE role, and the user performing the import will need the DATAPUMP_IMP_FULL_DATABASE role.
3. Check Source and target schema. If both schemas are different  then only use "REMAP_SCHEMA" parameter 
4. Check source and target tablespace. If both source and target  tablespace are different then  only use "REMAP_TABLESPACE" parameter.
		
		To check Tablespace of table : 
		
		col SEGMENT_NAME for a30
		col TABLESPACE_NAME for a30
		select SEGMENT_NAME,TABLESPACE_NAME from user_segments where SEGMENT_NAME='&SEGMENT_NAME' ;
		
5. Check Target tablespace size, It should be sufficient to import tables .

6. Command : - 
To take Export :-
expdp user/password  tables=SCHEMA.TABLE_NAME,SCHEMA.TABLE_NAME2 directory=directory_name dumpfile=db_name_user_name.dmp parallel=4 logfile=expdp_Logfile.log

e.g.
expdp user/password  tables=FINNQUERY.OFSA_RL1_DOWNLOAD_DTL,FINNQUERY.OFSA_HOME_MAIN,FINNQUERY.OFSA_PEMI_SCHEDULE,FINNQUERY.OFSA_EMI_SCHEDULE,FINNQUERY.OFSA_RL3_DOWNLOAD_DTL directory=TEST_EXPORT dumpfile=FINNQUERY_16MAR21.dmp parallel=4 logfile=impdpFINNQUERY_16MAR21.log


To do import :-
impdp  user/password directory=directory_name dumpfile=db_name_user_name.dmp REMAP_TABLESPACE=Source_tablespace:Target_Tablespace parallel=4 REMAP_SCHEMA=Source_Schema:Target_Schema logfile=impdp_logfile_16MAR21.log

e.g.

impdp  user/password directory=IMPDB dumpfile=FINNQUERY_16MAR21.dmp REMAP_TABLESPACE=FINN_TAB_SML_NEW:FINNMIS_DATA  REMAP_SCHEMA=FINNQUERY:MISBANK logfile=expdp_FINNQUERY_16MAR21.log



=======================Maximum Availability ========================================
Note:-
1.  DB unique name should be different on source & target
2.  Make sure dbs are running from SPFILE
3.  dg_broker_start should be false on both source & target
show parameter uniq
show parameter config
show parameter spfile
show parameter dg_broker_start

If same>> Change the db_unique_name to different post approval:
alter system set db_unique_name='EKYCPROD_FB' scope=spfile;

alter system set LOG_ARCHIVE_CONFIG='DG_CONFIG=(EKYCPROD,EKYCPROD_VM,EKYCPROD_VM_FB,EKYCPROD_DR)' scope=both;

Alter system set log_archive_dest_2='service=EKYCPROD_23 LGWR SYNC NOAFFIRM nodelay db_unique_name=EKYCPROD_VM
net_timeout=5 reopen=300 max_failure=5' scope=both;

For 11g database:
Alter system set log_archive_dest_2='service=WLIMBLIV_FB LGWR SYNC AFFIRM nodelay
db_unique_name=WLIMBLIV_FB net_timeout=5 reopen=300 max_failure=5' scope=both;

For 12c databases:
Alter system set log_archive_dest_2='service=EKYCPROD_VM_FB LGWR SYNC NOAFFIRM nodelay
db_unique_name=EKYCPROD_VM_FB net_timeout=5 reopen=300 max_failure=5' scope=both;

On Production:

	ALTER DATABASE SET STANDBY DATABASE TO MAXIMIZE AVAILABILITY;	

	ALTER DATABASE SET STANDBY DATABASE TO MAXIMIZE PERFORMANCE;	 

==========================================Control file muliplexing====================================================



alter database backup controlfile to '/DBHOME/control01_12April21.bk';


SQL> alter database backup controlfile to '/DBHOME/control01_12April21.bk';

Database altered.

SQL>


SQL> select name from v$controlfile;

NAME
--------------------------------------------------------------------------------
+EOTP_DATA/EOTPPROD/CONTROLFILE/current.262.1048875121
+EOTP_REDO1/EOTPPROD/CONTROLFILE/current.256.1048875123

SQL>

SQL> select NAME,TOTAL_MB,FREE_MB,TYPE,USABLE_FILE_MB,STATE from  v$asm_diskgroup;

NAME                             TOTAL_MB    FREE_MB USABLE_FILE_MB STATE
------------------------------ ---------- ---------- -------------- -----------
EOTP_ARCH                          512000     495574         495574 CONNECTED
EOTP_DATA                          614400     376138         376138 CONNECTED
EOTP_REDO1                          51200      49452          49452 CONNECTED
EOTP_REDO2                          51200      49476          49476 CONNECTED
MGMT                               204800     180500         180500 MOUNTED
OCR_VOTE                            51200      50236          19998 MOUNTED
EOTP_BUNKER_REDO                    20480      20417          20417 MOUNTED

7 rows selected.


NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
control_file_record_keep_time        integer     7
control_files                        string      +EOTP_DATA/EOTPPROD/CONTROLFIL
                                                 E/current.262.1048875121, +EOT
                                                 P_REDO1/EOTPPROD/CONTROLFILE/c
                                                 urrent.256.1048875123
control_management_pack_access       string      DIAGNOSTIC+TUNING
SQL


alter system set control_files='+EOTP_DATA/EOTPPROD/CONTROLFILE/current.262.1048875121','+EOTP_REDO1/EOTPPROD/CONTROLFILE/current.256.1048875123','+EOTP_BUNKER_REDO'
scope=spfile;


SQL> alter system set control_files='+EOTP_DATA/EOTPPROD/CONTROLFILE/current.262.1048875121','+EOTP_REDO1/EOTPPROD/CONTROLFILE/current.256.1048875123','+EOTP_BUNKER_REDO'
scope=spfile;  2

System altered.


srvctl start instance -d EOTPPROD -i EOTPPROD1 -o nomount


restore controlfile from '+EOTP_DATA/EOTPPROD/CONTROLFILE/current.262.1048875121';



RMAN> restore controlfile from '+EOTP_DATA/EOTPPROD/CONTROLFILE/current.262.1048875121';

Starting restore at 12-APR-21
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=689 instance=EOTPPROD1 device type=DISK

channel ORA_DISK_1: copied control file copy
output file name=+EOTP_DATA/EOTPPROD/CONTROLFILE/current.262.1048875121
output file name=+EOTP_REDO1/EOTPPROD/CONTROLFILE/current.256.1048875123
output file name=+EOTP_BUNKER_REDO/EOTPPROD/CONTROLFILE/current.256.1069702157
Finished restore at 12-APR-21

RMAN>

alter system set control_files='+EOTP_DATA/EOTPPROD/CONTROLFILE/current.262.1048875121','+EOTP_REDO1/EOTPPROD/CONTROLFILE/current.256.1048875123','+EOTP_BUNKER_REDO/EOTPPROD/CONTROLFILE/current.256.1069702157' scope=spfile;
farSync.html 

==================== RMAN backup command =========
RUN
{
  ALLOCATE CHANNEL ch11 TYPE DISK ;
  ALLOCATE CHANNEL ch12 TYPE DISK ;
  ALLOCATE CHANNEL ch13 TYPE DISK ;
  ALLOCATE CHANNEL ch14 TYPE DISK ;
  ALLOCATE CHANNEL ch15 TYPE DISK ;
  BACKUP
  AS COMPRESSED BACKUPSET
  FORMAT '/rrsprod3/RMAN/database_%d_DB_%u_%s_%p.bkp'
  DATABASE
  CURRENT CONTROLFILE
  FORMAT '/rrsprod3/RMAN/control_%d_DB_%u_%s_%p.bkp'
  SPFILE
  FORMAT '/rrsprod3/RMAN/spfile_%d_DB_%u_%s_%p.bkp';
  RELEASE CHANNEL ch11;
  RELEASE CHANNEL ch12;
  RELEASE CHANNEL ch13;
  RELEASE CHANNEL ch14;
  RELEASE CHANNEL ch15;
}
==========================================
$ lsdev | grep iocp
iocp0 Available I/O Completion Ports
==========================================

chmod 6751 /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/bin/oracle
chmod 600 /DBHOME/oracle/app/product/12.1.0.2/dbhome_1/bin/oracleO
=====================================IO errors===========================
 iostat -E    >>> show errors
 iostat -x    >>>  
=========================
tar cvzf MyImages-14-09-12.tgz /home/MyImages
=============
nohup sqlplus " / as sysdba " @awr-generate.sql &
========================================Add database to Cluster===============================
srvctl add database -db IRTGSPRD -oraclehome /ora12102/app/orabase/product/12.1.0/dbhome_1  -spfile +DATA/IRTGSPRD_COLO/PARAMETERFILE/spfile.489.1084538459
srvctl add instance -db IRTGSPRD -instance IRTGSPRD1 -node hostname1
srvctl add instance -db IRTGSPRD -instance IRTGSPRD2 -node hostname2

srvctl modify database -d PRIM -spfile +DATA/PRIM/spfile


======================Production Ip configuration in RAC ===========
How to Modify Public Network Information including VIP in Oracle Clusterware (Doc ID 276434.1)	
How to Modify Private Network Information in Oracle Clusterware (Doc ID 283684.1)

./oifcfg getif
########./oifcfg setif -public bond0/10.150.32.0   >> team 

./oifcfg getif 

./oifcfg setif -global bond0/10.150.32.1:public

./oifcfg delif -global ens1f1d1/10.150.73.0:public
./oifcfg delif -global ens1f1d1/10.150.73.0
./srvctl config nodeapps
./srvctl modify nodeapps -subnet 10.150.32.0/255.255.248.0/bond0
./srvctl config scan
./srvctl modify scan -scanname rtgscolofb-scan
./srvctl modify scan_listener -update

How to change Hostname / IP for a Grid Infrastructure Oracle Restart Standalone Configuration (SIHA) 11.2 and Later (Doc ID 1552810.1)	
==========================================================================
===============================Restore from Service=======================
nohup rman target /  cmdfile=datafile.cmd log=datafile.out & 

run
{
allocate channel c1 device type disk;
set newname for datafile 1021 to '+GIB_DATA';
set newname for database to '+DATA';
restore datafile 1098 from service GIBCLPRD_PROD;
restore database from service INEFTPRD_DR_1 ;
set newname for datafile 1985 to '/fcrmdata95/oradata/FCRM10DB/data/%b';
switch datafile all;
recover database;
RELEASE CHANNEL ch1;
}


IRTGSPRD_COLO =
   (ADDRESS_LIST =
        (ADDRESS = (PROTOCOL = TCP)(HOST = 10.150.32.77)(PORT = 1992))
   )
SID_LIST_IRTGSPRD_COLO =
 (SID_LIST =
  (SID_DESC =
    (GLOBAL_DBNAME = IRTGSPRD_COLO)   >>> UNique name
    (ORACLE_HOME = /ora12102/app/orabase/product/12.1.0/dbhome_1)
    (SID_NAME = IRTGSPRD1)            >>> Instance Name 
   )
 )

run
{ 
allocate channel c1 device type disk;
recover database from service IRTGSPRD_DR noredo using compressed backupset;
RELEASE CHANNEL c1;
}
 
GIBCLPRD_COLO =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.150.32.61)(PORT = 1605))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = GIBCLPRD_COLO)
    )
)

				
RMAN>  restore standby controlfile from service INEFTPRD_DR_1 ;

Starting restore at 24-SEP-21
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=362 device type=DISK

channel ORA_DISK_1: starting datafile backup set restore
channel ORA_DISK_1: using network backup set from service INEFTPRD_DR_1
channel ORA_DISK_1: restoring control file
channel ORA_DISK_1: restore complete, elapsed time: 00:00:08
output file name=+DATA/INEFTPRD_COLO/CONTROLFILE/current.256.1084125295
output file name=+FRA/INEFTPRD_COLO/CONTROLFILE/current.256.1084125301-i
Finished restore at 24-SEP-21


Recover standby database from service . 
   1)	Stop REDO apply in Mirror database 
		SQL> recover managed standby database cancel;

   2)	Shutdown and nomount DR database 
        SQL> shutdown immediate;
        SQL> startup nomount;

   3)	Restore standby control of Primary database using service name
        Note: The below errors fixed by changing the RMAN parameters in Primary database marked in green.  Location specified for those two parameters was not exists
        RMAN> restore standby controlfile from service Service_Name;

		Starting restore at 22-07-04
		using target database control file instead of recovery catalog
		allocated channel: ORA_DISK_1
		channel ORA_DISK_1: SID=1772 device type=DISK

		channel ORA_DISK_1: starting datafile backup set restore
		channel ORA_DISK_1: using network backup set from service Service_Name
		channel ORA_DISK_1: restoring control file
		channel ORA_DISK_1: restore complete, elapsed time: 00:00:15
		output file name="DATA/CTL/control01.ctl
		output file name=+DATA/CTL/control02.ctl
		Finished restore at 22-07-04

		RMAN>
		SQL> alter database mount;
		Database altered.
		
	4)	Catalog database, Ran multiple “catalog start with” commands because Data files located in Multiple paths
		RMAN>  catalog start with '+DATA'

	5)	Generate rename data files commands.  This command renames the data files name control file
		SQL> set pages 0 lines 300 echo off term off feedback off
		SQL> select 'alter database rename file ''' || df.name || ''' to ''' || fc.name || ''';'from v$datafile df join v$datafile_copy fc on df.file# = fc.file#;
		SQL> alter system set standby_file_management=manual scope=both;

		System altered.

		SQL>
	
	6) Recover database from service .
		RMAN> recover database from service Service_Name;
		nohup rman cmdfile=restore.cmd log=restore.log &
		connect target /
		run {
		allocate channel c50 type disk;
		recover database from service Service_Name;
		release channel c1;
		release channel c2;
		}
	7)	Restore data files only  for newly added data files errored out during step 5.  
		If No error in step 6 then this step should be skipped. -> no errors we can skip this.

		restore datafile <FILE_ID> from service <PRIMARY_SERVICE_NAME>;

		recover database from service GCTOMPR1;

	8)	Start the recovery

		SQL> recover managed standby database disconnect from session;
		Media recovery complete.
		SQL>

========= Roll forward the Standby with the backup =================================================
RMAN > CATALOG START WITH '/standbydisk1/incrback/';
RMAN > RECOVER DATABASE NOREDO;

=============================================== Open cusrsor =======================================
select a.value,s.sql_id, s.username, s.sid, s.serial# from v$sesstat a,
v$statname b, v$session s
where  a.value!=0 and a.statistic# = b.statistic# and s.sid=a.sid and b.name =
'opened cursors current' and s.sql_id is not null 
order by a.value desc;
===================================================== Switchover & switchback ===============================================
– Check whether Primary and Standby databases are in sync or not

On Primary database

SQL> select name, open_mode, database_role,switchover_status from gv$database;

SQL> select thread#, max(sequence#) from gv$archived_log where applied='YES' group by thread#;

On Standby database

SQL> select name, open_mode, database_role from v$database;
select max(sequence#) from gv$log_history;
SQL> select thread#, max(sequence#) from v$archived_log where applied='YES' group by thread#;

 
=================================================================================================================
– If Standby is in sync with Primary database then perform the Switchover

On Primary database
set job_queue_processes=0

alter sytem set job_queue_processes=0 sid='0';

SQL> select switchover_status from v$database;
SQL> alter database commit to switchover to standby with session shutdown;
SQL> shutdown immediate;
SQL> startup mount;
SQL> select name, open_mode, database_role from v$database;

On Standby database
SQL> select switchover_status from v$database;
SQL> alter database commit to switchover to primary with session shutdown;
SQL> shutdown immediate;
SQL> startup;
SQL> select name, open_mode, database_role from v$database;

====================================================================================================================
 

– Change the value of “log_archive_dest_state_2” parameter to defer and start recovery

On Primary Database – New Standby database

– Change the value of below parameter
SQL> alter system set log_archive_dest_state_2='defer';

– Start recovery on new standby database
SQL> recover managed standby database disconnect from session;

===================================================================================================================== 

– Change the value of “log_archive_dest_state_2” parameter to enable and do log switches

On Standby database – New Primary database

– Change the value of below parameter
SQL> alter system set log_archive_dest_state_2='enable';

– Switch logfiles 4-5 times and check whether they are getting applied on new standby database
SQL> alter system switch logfile;
SQL> select thread#, max(sequence#) from v$archived_log where applied='YES' group by thread#;

On Primary Database – New Standby database

SQL> select thread#, max(sequence#) from v$archived_log where applied='YES' group by thread#;

If the archive log files are getting applied on standby database, this concludes our SWITCHOVER activity.


After switchover Check TEMP File======
set lines 200 pages 200
col PROPERTY_VALUE for a40
col DESCRIPTION for a50
select * from database_properties where property_name like '%TEMP%';


PROPERTY_NAME                  PROPERTY_VALUE                           DESCRIPTION
------------------------------ ---------------------------------------- --------------------------------------------------
DEFAULT_TEMP_TABLESPACE        LMTEMP1                                  Name of default temporary tablespace
====================================== Dr To snapshot =================================================================================
DR -SNAPSHOT STANDBY
---------------------------Pre Activity:----------------------------

1.Check the database role and open  mode of the database. 
	Select name,open_mode,database_role from v$database;
2.Check the sync status of FALL/DR database with production.ensure FALL/DR in sync
3.Check the size of the partition where  DB_file_recovery_dest has to allocated OR take a separate partition for dest location.
Create a proper directory path eg:(/partiotion_name/DB name/FLASH)


---------------------------Activity( Physical to Snapshot)-----------------------------

	SQL>show parameter db_recovery_file_dest 
4.Set the dest loaction and DEST size. 
	Alter system set db_recovery_file_dest=’<Location>; 
	alter system set db_recovery_file_dest_size=<size>
	show parameter file_dest
5.Stop the recovery: 
	Alter database recover managed standby database cancel;
6.Check Flashback on status
	select flashback_on from v$database; (should be ‘NO’)
7.Convert to snapshot mode
	alter database convert to snapshot standby;
	select flashback_on from v$database; (should be restore point only)
	alter database open;
	select name,open_mode,database_role,controlfile_type from v$database;


--------------------Converting to standby database from flashback database.------------------

	select flashback_on from v$database;(should be ‘RESTORE POINT ONLY)
	select open_mode,database_role,controlfile_type from v$database; (should be in snapshot standy mode)
	show parameter file_dest

-------------------------------Convert Snapshot  to physical standby------------------------
	shut immediate;

	startup mount
	alter database convert to physical standby;
	select open_mode,database_role,controlfile_type from v$database; (should be in physical standby mode)
	alter database open read only;
	select open_mode,database_role,controlfile_type from v$database;
	recover managed standby database disconnect from session;
============================================================== Daily used script ==================================================

How to Modify Public Network Information including VIP in Oracle Clusterware (Doc ID 276434.1)
How to Update the IP Address of the SCAN VIP Resources (ora.scan{n}.vip) (Doc ID 952903.1)
How to Modify Private Network Information in Oracle Clusterware (Doc ID 283684.1)
How to Move RAC Database to New ORACLE_HOME Location (Doc ID 2117136.1)	

https://dbaclass.com/article/upgrade-grid-infrastructure-from-oracle-12c-to-19c/

    select owner,segment_type,count(*),sum(bytes)/1024/1024/1024 from dba_segments where owner='&OWNER' group by owner,segment_type;

	    alter session set nls_date_format = 'DD-Mon-YYYY HH24:MI:SS';
		set lines 200 pages 200
		select INST_ID,NAME,LOG_MODE,CONTROLFILE_TYPE,OPEN_MODE,DATABASE_ROLE,switchover_status,protection_mode,protection_level from gv$database;
		select INSTANCE_NUMBER,INSTANCE_NAME,HOST_NAME,STARTUP_TIME,STATUS from  gv$instance;

"_enable_ptime_update_for_sys"=true

Doc ID 885643.1
Doc 730365.1   - binarirs
DOC 2118136.2 - psu patches 
patch refer to Note 412160.1
Patches to apply before upgrading Oracle GI and DB to 18c or downgrading to previous release (Doc ID 2414935.1)
Patches to apply before upgrading Oracle GI and DB to 19c or downgrading to previous release (Doc ID 2539751.1)

How to Upgrade to/Downgrade from Grid Infrastructure 19c and Known Issues (Doc ID 2669766.1)
How To Find And Download GoldenGate On edelivery.oracle.com (Oracle Software Delivery Cloud) (Doc ID 965230.1)

Doc ID 2539778.1 - doc to upgrade to 19c
Master Note For Oracle Database Upgrades and Migrations (Doc ID 1152016.1)
How to Install 11.2 /12.1/12.2/18c/19c Database/Client Software in Silent Mode with/without Using Response File (Doc ID 885643.1)

select con_id, name, open_mode, total_size from v$pdbs;
alter pluggable database IFRSDEV open;
select * from gv$diag_info where name='Diag Trace';
select * from v$diag_info where name='Diag Trace';
select PROCESS,STATUS,THREAD#,SEQUENCE# from  v$managed_standby;
select SQL_ID,PLAN_HASH_VALUE,COST,CPU_COST,IO_COST,TIMESTAMP,TIME from DBA_HIST_SQL_PLAN where SQL_ID='&sql';
show alert -tail -f

select * from v$database_block_corruption ;

select a.SID,a.OWNER,a.OBJECT,b.serial#,b.sql_id,c.sql_text from v$access a,v$session b,v$sql c where a.OBJECT='&Object_Name' and a.sid=b.sid and b.sql_id=c.sql_id;

select username,status,count(*) from gv$session where status='INACTIVE' group by username,status;
select inst_id,username,status,count(*) from gv$session where status='ACTIVE' group by username,status,inst_id;
select INST_ID,username,status,count(*) from gv$session group by username,status,INST_ID order by INST_ID;
select username,status,count(*) from gv$session group by username,status;
select username,status,count(*) from v$session group by username,status;
select username,status,MACHINE,count(*) from gv$session group by username,status,MACHINE;
select * from gv$resource_limit where RESOURCE_NAME in ('processes','sessions');
select * from v$resource_limit where RESOURCE_NAME in ('processes','sessions');
DBMS_METADATA.GET_DDL('INDEX','ACS_LIAUDIT_DBF','MXGMLC')
select sum(space*8)/1024/1024 space_in_GB from dba_recyclebin;
select OWNER,count(*)from dba_tables where OWNER='OFSAAATM' and LAST_ANALYZED <=to_timestamp('05-APR-2020 01:30:00', 'DD-MON-YYYY HH24:MI:SS') group by OWNER;


select DISK_NUMBER,OS_MB,TOTAL_MB,FREE_MB,HOT_USED_MB,COLD_USED_MB,NAME,MOUNT_STATUS,path,HEADER_STATUS from v$asm_disk;

col NAME for a20
col COMPATIBILITY for a20
col DATABASE_COMPATIBILITY for a20
select NAME,TOTAL_MB,FREE_MB,USABLE_FILE_MB,STATE,COMPATIBILITY,DATABASE_COMPATIBILITY from  v$asm_diskgroup;

select NAME,TOTAL_MB,FREE_MB,USABLE_FILE_MB,STATE,TYPE from  v$asm_diskgroup;

ps -ef|grep IWCASA|grep -i local=no
AIX- memory size : prtconf |grep -i mem

select OWNER,JOB_NAME,ACTUAL_START_DATE,STATUS,RUN_DURATION,INSTANCE_ID,SESSION_ID from all_scheduler_job_run_details where JOB_NAME='&name' order by ACTUAL_START_DATE;
---
select pdb_name, username from dba_pdbs, cdb_users;
 alter session set events='60063';
alter system archive log current;  

select * from v$px_Session;

SELECT name, open_mode FROM v$pdbs;
SELECT con_name, instance_name, state FROM dba_pdb_saved_states;\

select OWNER,STALE_STATS,coun mot(*) from dba_tab_statistics where STALE_STATS='YES' group by OWNER,STALE_STATS;

select inst_id,username,status,sid,serial#,sql_id,MACHINE,LAST_CALL_ET/60 as Min from gv$session where sid=&sid;
select inst_id,username,status,sid,serial#,sql_id,LAST_CALL_ET/60 as Min from gv$session where sql_id='&sql_id';
select sql_fulltext from gv$sql where sql_id='&sql_id';
select name,CREATED from dba_sql_profiles where name like '%asr206v1sbu1v%';
SQL>select * from dba_tab_modifications where table_name='TBL_LB_TEMP_DWH';
select sql_fulltext from v$sql where sql_id='9qhj47b891ctq';

ps -ef | grep LOCAL=NO | wc -l

col owner for a30
col segment_name for a30
select owner,segment_name,sum(bytes)/1024/1024/1024 from dba_segments where segment_name='&segment_name' group by owner,segment_name ;

@?/rdbms/admin/sqltrpt.sql

alter database recover automatic managed standby database disconnect from session ;

			=== z1===

			alter session set nls_date_format = 'DD-Mon-YYYY HH24:MI:SS';
			set lines 200 pages 200
			select NAME,LOG_MODE,CONTROLFILE_TYPE,OPEN_MODE,DATABASE_ROLE,switchover_status,protection_mode,protection_level from gv$database;
			select INSTANCE_NUMBER,INSTANCE_NAME,HOST_NAME,STARTUP_TIME,STATUS from  gv$instance;
	
	alter database set standby database to maximize availability ;
	
alter database recover automatic managed standby database disconnect from session noparallel 5;
alter database recover automatic managed standby database disconnect from session parallel 10;

alter database recover managed standby database disconnect from session ;
alter database recover managed standby database disconnect from session  using current logfile;

alter database recover managed standby database DELAY 300 disconnect from session ;   >>> 11g
alter database recover managed standby database noDELAY disconnect from session ;   >>> 11g

alter database recover managed standby database using archived logfile disconnect;    >>> 12c onwords

alter database recover managed standby database cancel;

select NAME,LOG_MODE,CONTROLFILE_TYPE,OPEN_MODE,DATABASE_ROLE,switchover_status from gv$database;

	col DEST_NAME for a40
	select INST_ID,DEST_ID,DEST_NAME,status,ERROR from gv$ARCHIVE_DEST_STATUS;
	 
 SELECT thread#, dest_id, gvad.status, error, fail_sequence FROM gv$archive_dest gvad, gv$instance gvi WHERE gvad.inst_id = gvi.inst_id AND destination is NOT NULL ORDER BY thread#, dest_id;
SELECT gvi.thread#, timestamp, message FROM gv$dataguard_status gvds, gv$instance gvi WHERE gvds.inst_id = gvi.inst_id AND severity in ('Error','Fatal') ORDER BY timestamp, thread#;

select max(sequence#) from gv$log_history;
select thread#, max(sequence#) from gv$archived_log group by thread#;
select thread#, max(sequence#) from gv$archived_log where applied='YES' group by thread#;
	select PROCESS,STATUS,THREAD#,SEQUENCE# from  gv$managed_standby;
select max(sequence#) from gv$archived_log where dest_id=1;
select max(sequence#),dest_id from gv$archived_log where applied='YES' group by dest_id;

	alter session set nls_date_format = 'DD-Mon-YYYY HH24:MI:SS';
	select distinct(checkpoint_time) from v$datafile_header ;
	
	SELECT SUBSTR(value,INSTR(value,'=',INSTR(UPPER(value),'SERVICE'))+1) FROM v$parameter WHERE name LIKE 'log_archive_dest%' AND UPPER(value) LIKE 'SERVICE%';

set lines 200 pages 300
col COMP_NAME for a40
SELECT Comp_ID, Status, Version,Comp_Name FROM DBA_Registry ORDER by 1,2;
	
	
	select * from v$recover_file;
	select inst_id,sequence#,to_char(completion_time,'dd-mm-yyyy hh24:mi')from gv$archived_log where sequence#=&seqno;
	
select OWNER,TABLE_NAME,COLUMN_NAME,HISTOGRAM from dba_TAB_COLUMNS where TABLE_NAME in ('LEADS','ACTIVITY') and HISTOGRAM not like 'NONE';

/var/opt/oracle/oratab

datapatch -verbose
srvctl status database -d IDCMSUAT
srvctl start database  -d IDCMSUAT -o mount
brows backup
/usr/openv/netbackup/bin/bplist -C hostname -k RMAN_IBGNSAML-BIWEEKLY -t 4 -R -s 09/28/2017 -e 09/28/2017 -l /

select owner,segment_type,count(*) from dba_segments where owner='&owner' group by owner,segment_type;

alter system archive log current
prstat -a

https://docs.oracle.com/database/121/ARPLS/d_stats.htm#ARPLS68494
**************************DR_Status************************************************************************************************ora12201

adrci    - for alert log location
kill_od_1.sql
set lines 1000 pages 1000
select * from v$resource_limit;
srvctl status database -d IPGPROD
 
column fee format 999999999.99
sqlplus sys/dba_ic09 as sysdba
set lines 1000 pages 1000
select inst_id,name,open_mode,database_role,switchover_status,log_mode,protection_mode from gv$database;
SELECT STARTUP_TIME FROM dba_hist_database_instance ORDER BY startup_time DESC;
select NAME,TOTAL_MB,FREE_MB,USABLE_FILE_MB from v$asm_diskgroup;
Completed: ALTER DATABASE RECOVER MANAGED STANDBY DATABASE UNTIl CHANGE                                        13502160817563

select owner,index_name,STATUS from dba_indexes where status='UNUSABLE';
select name, value from v$dataguard_stats;

DR------
alter database recover managed standby database disconnect from session parallel 10;
alter database recover automatic managed standby database disconnect from session;

 alter database recover automatic managed standby database using archived logfile disconnect;
 
alter database recover managed standby database cancel;

alter database recover managed standby database cancel;
col DEST_NAME for a50
col ERROR for a50
set line 1000 pages 1000
select DEST_ID,DEST_NAME,ERROR from gv$archive_dest_status;
select max(sequence#) from gv$log_history;
SELECT THREAD#, max(SEQUENCE#)  FROM V$THREAD group by THREAD# where applied='YES';


select dest_id,status,error from v$archive_dest;
alter system set log_archive_dest_state_2=enable;
alter system set log_archive_dest_state_2=defer;
select thread#, max(sequence#) from gv$archived_log group by thread#;
select max(sequence#),dest_id from gv$archived_log where applied='YES' group by dest_id;
select max(sequence#),thread# from gv$archived_log where applied='YES' group by thread#;
select INST_ID,PROCESS,STATUS,client_process,thread#,sequence# from gV$MANAGED_STANDBY;
select DEST_ID,SEQUENCE#,ARCHIVED,APPLIED,STATUS,COMPLETION_TIME from v$archived_log where trunc(COMPLETION_TIME)=trunc(sysdate);
SELECT STARTUP_TIME FROM dba_hist_database_instance ORDER BY startup_time DESC;
***************************************************************************************************************************************
sqlwork> srvctl status -d database FINN1
select OWNER,SEGMENT_NAME,SEGMENT_TYPE,TABLESPACE_NAME,BYTES/1024/1024 from dba_segments where TABLESPACE_NAME='NOSTRODATA' order by 5 desc
col owner for a10;
SQL >select segment_name,segment_type,bytes/1024/1024 MB from dba_segments where segment_type='TABLE' and segment_name='IVR_CALL_TXN';
**************************************************************************************************************************************
set lines 1000 pages 1000
select BLOCKING_SESSION,sid,serial#,wait_class,seconds_in_wait from gv$session where BLOCKING_SESSION is not null order by BLOCKING_SESSION;
blockh.sql*********
select /*+ ordered*/ blocker.sid blocker_sid,waiting.sid waiting_sid,trunc(waiting.ctime/60) min_waiting,waiting.request from (select * from gv$lock where block !=0 and type ='TX') blocker,gv$Lock waiting where waiting.type='TX' and
waiting.block=0 and waiting.id1=blocker.id1 order by 3 desc;
select inst_id,sid,serial#,status,sql_id from gv$session where sql_id='81hhxw5fwypqn';
 alter system kill session '823,35321' immediate ;
81hhxw5fwypqn

 select SQL_ID,SID,SQL_TEXT from v$open_cursor where SQL_TEXT like '%CPP_CANDIDATE_TEMP_FETCH%';

 opatch lsinv |grep applied

oem space release---------------
/usr/bin/find /oem10g -name heap* -exec /bin/rm -f {} \;
select * from v$transportable_platform order by platform_name;

 isainfo -b for os bit version.

------------------------------------------------------------------------
------------------------------------------------------------
AIX-Based Systems (64-bit)  			------Big Indian
Linux x86 64-bit						------Little Indian
Microsoft Windows x86 64-bit			------Little Indian
Solaris Operating System (x86-64)       ------Little Indian
Solaris[tm] OE (64-bit)					------Big Indian
SunOS 5.10
--------------------------------------------------------------

select name from v$event_name where wait_class = 'Idle' order by name;

----------------------------check ram usage aix------------------
svmon -G
================
select rpad(a.tablespace_name,20) tablespace,
trunc(sum(a.tots/1024/1024)) Size_MB,
trunc(sum(a.sumb/1024/1024)) Free_MB
from 
( 
select tablespace_name,0 tots,sum(bytes) sumb,
max(bytes)largest,count(*) chunks 
from dba_free_space a
group by tablespace_name
union 
select tablespace_name,sum(bytes) tots,0,0,0
from  dba_data_files group by tablespace_name) a 
group by a.tablespace_name
order by 2 desc;

==========================================
 tnsping OMS_DR |grep DESCRIPTION |awk '{print $14}' |cut -d")" -f1
  id |cut -d "(" -f2 | cut -d ")" -f1

 cat flat.txt |grep M_CORESA_R |cut -d"_" -f2 | cut -d "_" -f1

===================================== Rac prerequisite =============================
Kindly find the pre-requisites for the RAC configuration .
Change Call : Induction change call 
Shared Storage (Multimap with both the nodes):
DATA DG : 10 disk of 100Gb each
ARCH DG : 2 disk of 250Gb each
REDO1 DG : 2 disks of 25Gb each
REDO2 DG : 2 disks of 25Gb each
MGMTDB DG  : 2 disks of 200GB each
OCRDATA DG : 5 disks of 50gb each

Non-Shared Storage each node:
/GRIDHOME : 100GB
/DBHOME : 100GB
/oradump : 50Gb
/oem12c : 20Gb

OS users and groups per node:

grid:!:1100:1000::/GRIDHOME:/usr/bin/ksh
ora12102:!:1103:1000::/DBHOME:/usr/bin/ksh
oem12c:!:212:1000::/oem12c:/usr/bin/ksh

oinstall:!:1000:ora12102,grid,oem12c
dba:!:2000:ora12102,grid
asmadmin:!:3000:ora12102,grid
oper:!:4000:ora12102,grid
asmdba:!:5000:ora12102,grid

IP:
2 PhysicalIPs ,2 Virtual Ips and 3 SCANIPs in same subnet
2 PrivateIPs different subnet as compared to physical,vip and scanips

============================== disable auto task ===========================================================
set lines 200 pages 300
SELECT CLIENT_NAME, STATUS FROM DBA_AUTOTASK_CLIENT;

CLIENT_NAME                                                      STATUS
---------------------------------------------------------------- --------
auto space advisor                                               ENABLED
auto optimizer stats collection                                  ENABLED
sql tuning advisor                                               ENABLED

SQL> exec DBMS_AUTO_TASK_ADMIN.DISABLE();

PL/SQL procedure successfully completed.

SQL> exec DBMS_AUTO_TASK_ADMIN.DISABLE('AUTO OPTIMIZER STATS COLLECTION',NULL, NULL);

PL/SQL procedure successfully completed.

SQL>  exec DBMS_AUTO_TASK_ADMIN.DISABLE('AUTO SPACE ADVISOR',NULL, NULL);

PL/SQL procedure successfully completed.

SQL> exec DBMS_AUTO_TASK_ADMIN.DISABLE('SQL TUNING ADVISOR',NULL, NULL);

PL/SQL procedure successfully completed.

SQL>  SELECT CLIENT_NAME, STATUS FROM DBA_AUTOTASK_CLIENT;

CLIENT_NAME                                                      STATUS
---------------------------------------------------------------- --------
auto space advisor                                               DISABLED
auto optimizer stats collection                                  DISABLED
sql tuning advisor                                               DISABLED

SQL>
====================================== Backup restoration auxiliary ===========================================
Connect target /
Run {
Allocate channel c1 type disk;
Allocate channel c2 type disk;
Allocate channel c3 type disk;
Allocate channel c4 type disk;
sql 'ALTER SYSTEM ARCHIVE LOG CURRENT';
BACKUP AS COMPRESSED BACKUPSET DATABASE FORMAT '/ub01/issues/COGECO-XXXXX_hot_backup_dery_migration/df_t%t_s%s_p%p_%U';
Backup archivelog all format '/ub01/issues/COGECO-XXXXX_hot_backup_dery_migration/%t_%s_%r.dbf';
Backup current controlfile format '/ub01/issues/COGECO-XXXXX_hot_backup_dery_migration/cgtma4_controlfile.dbf';
Release channel c1;
Release channel c2;
Release channel c3;
Release channel c4;
}


Connect AUXILIARY /
run
{
ALLOCATE AUXILIARY CHANNEL AUX1 TYPE DISK;
ALLOCATE AUXILIARY CHANNEL AUX2 TYPE DISK;
ALLOCATE AUXILIARY CHANNEL AUX3 TYPE DISK;
ALLOCATE AUXILIARY CHANNEL AUX4 TYPE DISK;
ALLOCATE AUXILIARY CHANNEL AUX5 TYPE DISK;
ALLOCATE AUXILIARY CHANNEL AUX6 TYPE DISK;
set newname for database to '+RB_DATA';
DUPLICATE DATABASE TO CGRBA2
BACKUP LOCATION '/ub01/issues/COGECO-103594_hotbackup_TST2_build/RB' nofilenamecheck
LOGFILE
GROUP 1 ('+RB_REDOA','+RB_REDOB') SIZE 512M REUSE,
GROUP 2 ('+RB_REDOA','+RB_REDOB') SIZE 512M REUSE,
GROUP 3 ('+RB_REDOA','+RB_REDOB') SIZE 512M REUSE;
RELEASE CHANNEL AUX1;
RELEASE CHANNEL AUX2;
RELEASE CHANNEL AUX3;
RELEASE CHANNEL AUX4;
RELEASE CHANNEL AUX5;
RELEASE CHANNEL AUX6;
}


>>>> nofilenamecheck  >>> use this keyword if source and target db_name/datafile location is same ..



cat restore.cmd
run
{
ALLOCATE CHANNEL ch1 TYPE DISK;
ALLOCATE CHANNEL ch2 TYPE DISK;
ALLOCATE CHANNEL ch3 TYPE DISK;
ALLOCATE CHANNEL ch4 TYPE DISK;
set newname for database to '+RB_DATA';
RESTORE DATABASE
SKIP TABLESPACE FDEDFAJDELETE_DATA;
recover database;
alter database open resetlogs;
RELEASE CHANNEL ch1;
RELEASE CHANNEL ch2;
RELEASE CHANNEL ch3;
RELEASE CHANNEL ch4;
}

=======================================gg Golden Gate ===============================================================================




=====================================Signle account extract - GCI=========================================
/opt/oracle/dba/issues/misc_extract_load_scripts/obfuscated_version_scripts/export_customers_single.ksh

export_customers_single.ksh
export_accounts_single.ksh

Modify the EXPORT USER, Ticket Number and ACCOUNT_NUM in KSH files.
====================================================User level trace======================================================
trace manually

execute sys.dbms_system.set_ev(sid,serial#,10046,13,''); - Start trace


execute sys.dbms_system.set_ev(361,41731,10046,0,''); - Stop trace



user level Logon trigger for trace 10046

create or replace trigger login_trigger3
after logon on database
begin
if (USER in ('ECSSTAGE_CISDATAHUB_STAGE_ETL','ECS_HUB_ADMIN')) then
execute immediate
'ALTER SESSION SET EVENTS ''10046 TRACE NAME CONTEXT FOREVER, LEVEL 12''';
end if;
end;
/
==========================================================================================================================
execute sys.dbms_system.set_ev(45,4079,10046,13,''); - Start trace
EXECUTE dbms_system.set_ev (45,4079,10046,0,''); stop trace
SELECT p.tracefile FROM v$session s JOIN v$process p ON s.paddr = p.addr WHERE s.username = 'UNIF_ADMIN';

/home/oracle/app/oracle/diag/rdbms/cgrbt4/cgrbt4/trace/cgrbt4_ora_56742.trc

select spid from v$process where addr = (select paddr from v$session where sid=&SID);
select sid from v$session where paddr = (select addr from v$process where spid=&spid);
oradebug SETOSPID 19664
oradebug SETOSPID 17171
oradebug SETOSPID 131728


oradebug SETOSPID 80507


oradebug UNLIMIT
oradebug EVENT 10046 trace name context forever,level 12;
oradebug TRACEFILE_NAME

oradebug SETOSPID 56742
oradebug EVENT 10046 trace name context off;  To close Trace
oradebug CLOSE_TRACE; To close Trace


oradebug SETOSPID 19664
oradebug SETOSPID 17171
oradebug SETOSPID 131728

===============================================
Other Method :
execute sys.dbms_system.set_ev(sid,serial#,10046,13,''); - Start trace
execute sys.dbms_system.set_ev(361,41731,10046,0,''); - Stop trace
=====================================================================


ALTER SESSION SET EVENTS 10046 TRACE NAME CONTEXT off ;


column line format a79
set heading off
select 'ospid: ' || p.spid || ' # ''' ||s.sid||','||s.serial#||''' '||
s.osuser || ' ' ||s.machine ||' '||s.username ||' '||s.program line
from v$session s , v$process p
where p.addr = s.paddr
and s.username <> ' ';
=======================================  JAVA ====================================
ORA-29548: Java system class reported: release of Java system classes in the database (12.1.0.2.200714 1.6) does not match that of the oracle executable 
ORA-29548 : Java system  class reported : release or Java system classes in 
select dbms_java.get_jdk_version() from dual;

@?/javavm/install/update_javavm_db.sql  >>> Need to execute after breakfix refresh .

=================================== password file ================================
select USERNAME,AUTHENTICATION_TYPE from v$pwfile_users
========================================== Huge page size ========================================

memlock * 1024

egrep -i "shmmax|shmall|huge" /etc/sysctl.conf|grep -v "#"
SGA+PGA = Memlock values 

=============================== Restoration Status ========
select count(*)||' datafiles restored.' RESTORE_STATUS from v$datafile_header where bytes <> 0
union all
select count(*)||' datafiles to be restored.' from v$datafile_header where bytes = 0
/
=======================================Disk size===========================================================
cat /proc/partitions <-- shows the device sizes in KB
ls -l /dev/oracle <-- shows our DB raw devices with machine name
blockdev --getsize64 /dev/oracle/raw01 <-- shows the device size in bytes

===================  Drop trigger ==============================
select 'drop trigger '||owner||'.'||trigger_name||' ;' from dba_triggers where owner in
('GENEVA_ADMIN','RBM_CUSTOM','EBOS_ADMIN','COLL_ADMIN','CGTMA_20000','CGTMA_34000','CGTMA_11000');
======================================sql tunning adavisory ==========================
@?/rdbms/admin/sqltrpt.sql

set lines 300 long 1000000 longchunksize 10000000 pages 5000 verify off
select dbms_sqltune.report_sql_monitor('&sql_id',type=>'TEXT',report_level=>'ALL') FROM DUAL;

====================================set diskcovery string with kfod==================================================
 kfod status=TRUE asm_diskstring='/dev/oracle/*' disks=ALL
==============================================================drop diskgroup=========================================
SQL> drop diskgroup TOMS_DATA force INCLUDING contents;

Diskgroup dropped.

SQL> create diskgroup TOMS_DATA external redundancy disk '/dev/oracle/asmdata01';

Diskgroup created.

SQL>
SQL>
SQL> alter diskgroup TOMS_DATA add disk '/dev/oracle/asmdata02','/dev/oracle/asmdata03','/dev/oracle/asmdata04' rebalance power 6;

Diskgroup altered.


=============================Restore status====================================================

select count(*)||' datafiles restored.' RESTORE_STATUS from v$datafile_header where bytes <> 0
union all
select count(*)||' datafiles to be restored.' from v$datafile_header where bytes = 0
/
===============================================================================================
AIX and LINUX under : /etc/oraInst.loc
Other UNIX machines : /vat/opt/oracle/oraInst.loc
WINDOWS (Registry): HKEY_LOCAL_MACHINE > Software > Oracle > INST_LOC


Please give me o/p with root user 


nohup rman cmdfile=rman_restore.cmd log=restore_database_22032022.log &


Status ::::::::::::::::::::::::::

RB TOMB backup copy in progress .
TOMS NEW prod restoation is in progress .
Slice refresh in Trainning environment is in progress .
Swap space was modified to 16Gb  for New NG envionments. All databases are up and running . 



 ALTER SYSTEM SET log_archive_config='dg_config=(cgrbprd,cgrbprdstby,cgrbprddr,cgrbprdnew)'  scope=both;
 ==============================CDC PRoceed lag==============================================================
 DO not delete archives on this date .
 SELECT APPLY_NAME,
(HWM_TIME-HWM_MESSAGE_CREATE_TIME)*86400 "Latency in Seconds",
TO_CHAR(HWM_MESSAGE_CREATE_TIME,'HH24:MI:SS MM/DD/YY')
"Message Creation",
TO_CHAR(HWM_TIME,'HH24:MI:SS MM/DD/YY') "Apply Time",
HWM_MESSAGE_NUMBER
FROM V$STREAMS_APPLY_COORDINATOR order by APPLY_NAME;
==================================== DROP Db database link ========================================================================
CREATE PROCEDURE CGTMP_7000_HDS.drop_db_link AS
BEGIN
EXECUTE IMMEDIATE 'drop database link DBLINK_TO_NC';
END drop_db_link;
/
exec CGTMP_7000_HDS.drop_db_link
drop procedure CGTMP_7000_HDS.drop_db_link;
========== reclaim datafile size resize datafile=====
 select 'alter database datafile '||''''||b.file_name||''''||' resize '||round(((c.max_blockid+a.blocks) *8192)/1024/1024 + 10) ||'M ;'
from dba_extents a, dba_data_files b ,
(select file_id, max(block_id) max_blockid from dba_extents group by file_id) c
where a.file_id=b.file_id and a.file_id=c.file_id and a.block_id = c.max_blockid
and b.TABLESPACE_NAME='&ts';
==================================================run cluvfy & runInstaller================================================
./runcluvfy.sh stage -pre crsinst -n cgrbddb11cs,cgrbddb12cs
./gridSetup.sh –applyRU /ub01/software/19c_software/19c_latest_RU/GIPSU/33182768
=================================================================== parallel error ========================================================
In sql monitor report , DONE(ERROR) occurs when one of the parallel slaves has been inactive for more than 30 minutes.. It is an expected behavior... SQL is still executing.. check with the below SQL

SELECT
sql_id,
process_name,
status
FROM v$sql_monitor
WHERE sql_id = '&sql_id'
AND status ='EXECUTING'
ORDER BY process_name ;
======================================
srvctl relocate service -s service_name -d db_name -i 2ndinstance -t 1stinstace
========================== Reco size =====================
column Name format a17
SELECT Name, (SPACE_LIMIT/1024/1024/1024) Space_Limit_GB, SPACE_USED/1024/1024/1024 Space_Used_GB, SPACE_RECLAIMABLE/1024/1024/1024, NUMBER_OF_FILES
FROM V$RECOVERY_FILE_DEST;

select name,space_limit/1024/1024/1024 limit,space_used/1024/1024/1024,ROUND((SPACE_USED - SPACE_RECLAIMABLE)/SPACE_LIMIT * 100, 1) as Percent_Full from v$recovery_file_dest;
=========================================================
4375 5183 3660 3006
01/23
708




srvctl relocate service -s cgtompn_clust_new -d cgtompn -i cgtompn2 -t cgtompn1




gcshpdb01cn and gcshpdb02cn



Dear Linux Team,

Please execute below command on server "gcshpdb01cn" & "gcshpdb02cn"  one after the other . 

/u01/grid/12.1.0/bin/crsctl stop crs
/u01/grid/12.1.0/bin/crsctl config crs
/u01/grid/12.1.0/bin/crsctl disable crs
/u01/grid/12.1.0/bin/crsctl config crs


Good afternnon sir,
On GCI PROD Server including backup server new storage NFS migration is scheduled .  But on the backup server gci rb full backup is running . So informed them that if grid services brought down then backup will
	
============================================
GG upgrade : How To Handle OGG During Database Upgrade (Doc ID 2657958.1)
============================================supplemental gg ====================

select supplemental_log_data_min, supplemental_log_data_pk from v$database;

select gg_owner,gg_table_name
from gg_tablelist where gg_owner='&OWNER'
and gg_owner||gg_table_name not in
(select owner||table_name from dba_log_groups where log_group_type='ALL COLUMN LOGGING');

SELECT TABLE_NAME,SUPPLEMENTAL_LOG_DATA_PK log_pk,SUPPLEMENTAL_LOG_DATA_FK log_fk,SUPPLEMENTAL_LOG_DATA_UI log_ui,SUPPLEMENTAL_LOG_DATA_ALL log_all from DBA_CAPTURE_PREPARED_TABLES where table_owner='RBM_CUSTOM';
===========================================================================
Raw disk usage
cd /dev/oracle
lsof raw*
==================================================
Autonomous Health Framework (AHF) On-Premise (Doc ID 2832630.1)



./ahf_setup -ahf_loc /u01/oracle/grid/ahf/ahf_loc -data_dir /u01/oracle/grid/ahf/data_dir


==================================================
INSTALL DB 19c Binaries along with RU DB PSU patches

Create 19c db home: /opt/oracle/product/19c
Unzip db software :
unzip -q /ub01/software/19c_software/LINUX.X64_193000_db_home.zip -d /opt/oracle/product/19c
copy latest OPatch utility:
cp /ub01/software/19c_software/p6880880_122010_Linux-x86-64.zip /19c_software/LINUX.X64_193000_db_home.zip -d /

Verify OPatch version in Oracle home
cd $ORACLE_HOME
mv OPatch OPatch_bkp
unzip latest OPatch software (unzip p6880880_122010_Linux-x86-64.zip)
validate OPatch version -> cd $GRID_HOME/OPatch/opatch version




Here we executed binaries installation + latest DB RU at same time.
Initially it apply latest DB PSU then GUI open for binaries installation.

Server name: cgrbm1dbv01cn
Cd /opt/oracle/product/19c
cd /ub01/software/19c_software/19c_latest_RU/DBPSU
unzip p33192793_190000_Linux-x86-64.zip
Cd /opt/oracle/product/19c
initiate : ./runInstaller -applyRU /ub01/software/Patches_19c_upgrade/19c_GRID_DB_PSU/DBPSU/33192793
work Log:
[cgrba5dbv01cn.gms.netcracker.com:cgrba5] /opt/oracle/product/19c:RB NG TEST5> # ./runInstaller -applyRU /ub01/software/Patches_19c_upgrade/19c_GRID_DB_PSU/DBPSU/33192793

============================== Control file Autobackup ==============================
CONFIGURE CONTROLFILE AUTOBACKUP FORMAT '/ub01/snapshot_controlfile/cgtompndr/autobackup/%u.bkp';
==========================================================================================================
Pre-Image for COGECO - ACTUAL PROD :
[cgrbpdb01cn.gms.netcracker.com:cgrbprd1] /home/oracle:PRODUCTION> #  srvctl status service -d cgrbprd
Service BATCH_SERVICE is running on instance(s) cgrbprd1
Service cgrbprd1 is running on instance(s) cgrbprd1
Service cgrbprd2 is not running.
Service gg_service is running on instance(s) cgrbprd2

==================================================  sqlnet.ora ==============================================================================
Authentication methods available with Oracle Net Services:

none for no authentication methods, including Microsoft Windows native operating system authentication. When SQLNET.AUTHENTICATION_SERVICES is set to none, a valid user name and password can be used to access the database.
all for all authentication methods.
beq for native operating system authentication for operating systems other than Microsoft Windows
kerberos5 for Kerberos authentication
nts for Microsoft Windows native operating system authentication
radius for Remote Authentication Dial-In User Service (RADIUS) authentication
tcps for TLS authentication

======================== Release Flashback logs ================================
ALTER SYSTEM SET db_recovery_file_dest_size='3600G' SCOPE=BOTH;

column Name format a17
SELECT Name, (SPACE_LIMIT/1024/1024/1024) Space_Limit_GB, SPACE_USED/1024/1024/1024 Space_Used_GB, SPACE_RECLAIMABLE/1024/1024/1024, NUMBER_OF_FILES
FROM V$RECOVERY_FILE_DEST;


col name     format a32
col size_mb  format 999,999,999
col used_mb  format 999,999,999
col pct_used format 999
select
   name,
   ceil( space_limit / 1024 / 1024) size_mb,
   ceil( space_used / 1024 / 1024) used_mb,
   decode( nvl( space_used, 0),0, 0,
   ceil ( ( space_used / space_limit) * 100) ) pct_used
 from
    v$RECOVERY_FILE_DEST
===============================================================================



[cgrbpdb02cn.gms.netcracker.com:cgrbprd2] /home/oracle:PRODUCTION> #  crontab -l | grep -i "AR_Rpt"  | grep -i "create"
01 00 01 * * /opt/oracle/dba/common/app/Monthly_AR_Reports/bin/create_Mnthly_AR_Rpts_objects -s cgrbprd2  >/dev/null 2>&1


nohup sh /opt/oracle/dba/common/app/Monthly_AR_Reports/bin/create_Mnthly_AR_Rpts_objects -s cgrbprd2 &
=========================== stop management listener ================================

srvctl modify mgmtlsnr -endpoints TCP:1524 ,
srvctl stop mgmtlsnr ,
srvctl start mgmtlsnr ,
srvctl config mgmtlsnr
================================================ Resume GUI =====================================

How to Complete Grid Infrastructure Configuration Assistant(Plug-in) if OUI is not Available (Doc ID 1360798.1)

====================================================  Remove socket files =================================

# rm -f /usr/tmp/.oracle/*
# rm -f /tmp/.oracle/*
# rm -f /var/tmp/.oracle/*

==========================================================================================================

unzip -q /ub01/software/19c_software/LINUX.X64_193000_db_home.zip -d /u01/oracle/product/19c
./runInstaller -applyRU /ub01/software/19c_software/19c_latest_RU/DBPSU/33192793

==========================================================================================================

Oracle 19c - Complete Checklist for Manual Upgrades to Non-CDB Oracle Database 19c (Doc ID 2539778.1)
========================
AutoUpgrade Tool (Doc ID 2485457.1)
https://docs.oracle.com/en/database/oracle/oracle-database/21/upgrd/using-autoupgrade-oracle-database-upgrades.html#GUID-71883C8C-7A34-4E93-8955-040CB04F2109
=======================10g password =====================
set lines 200 pages 300
col username for a30
col password_versions for a30
SELECT USERNAME,password_versions FROM DBA_USERS 
WHERE ( PASSWORD_VERSIONS = '10G '
OR PASSWORD_VERSIONS = '10G HTTP ')
AND USERNAME <> 'ANONYMOUS';
==============================s

======================  Disable Scheduler ===============================
Dynamic Query for DISABLE scheduler jobs
select 'execute dbms_scheduler.disable('||''''||OWNER||'.'||job_name||''''||'); ' from all_scheduler_jobs where ENABLED='TRUE';

select ATTRIBUTE_NAME,VALUE from DBA_SCHEDULER_GLOBAL_ATTRIBUTE;

Useful queries :
execute dbms_scheduler.enable('PURGE_LOG');
execute dbms_scheduler.run_job('PURGE_LOG');
execute dbms_scheduler.disable('PURGE_LOG');


BEGIN
  DBMS_SCHEDULER.SET_ATTRIBUTE (
   'mytestjob', 'logging_level', DBMS_SCHEDULER.LOGGING_FAILED_RUNS);
END;
/


JOB Failed errors 

SELECT to_char(log_date, 'DD-MON-YY HH24:MM:SS') TIMESTAMP, job_name, status,
   SUBSTR(additional_info, 1, 40) ADDITIONAL_INFO
   FROM user_scheduler_job_run_details ORDER BY log_date;

========================================================================= sqlplus issues =======
Below permission to give to get access from other user .
libocci.so.19.1

============================================ CATLOG /CATPROC componenet are valide ====================================================
SQL > execute DBMS_REGISTRY_SYS.VALIDATE_CATPROC;
SQL > execute DBMS_REGISTRY_SYS.VALIDATE_CATALOG;
SQL > execute dbms_regxdb.validatexdb;



================================ APEX Installation ==================

GCTOMA1
cd /ub01/software/19c_softwares/APEX_21/apex
sqlplus / as sysdba
SQL> @apexins.sql SYSAUX SYSAUX NC_TEMP /i/

Before old APEX user drop disable below trigger:
alter trigger SYS.SDO_DROP_USER enable;
drop user APEX_040200 cascade;



@apexins.sql SYSAUX SYSAUX NC_TEMP /i/

================================

col NAME for a20
col COMPATIBILITY for a20
col DATABASE_COMPATIBILITY for a20
select NAME,TOTAL_MB,FREE_MB,USABLE_FILE_MB,STATE,COMPATIBILITY,DATABASE_COMPATIBILITY from  v$asm_diskgroup;

col ASMNAME_KFDSK for a30
col FAILNAME_KFDSK for a30
col LABEL_KFDSK for a30
SELECT ASMNAME_KFDSK, FAILNAME_KFDSK, LABEL_KFDSK FROM x$kfdsk;
======================fuzzyness=====================
alter session set nls_date_format='DD-MON-YYYY HH24:MI:SS' ;
set lines 400
column NAME format a70
column ERROR format a50
column CHECKPOINT_CHANGE# format 99999999999999
select fuzzy, status, error, recover, checkpoint_change#, checkpoint_time, count(*)
from v$datafile_header
group by fuzzy, status,error, recover, checkpoint_change#, checkpoint_time
order by 5;


select * from (select file#,name,substr(status,1,3) sta,error err,recover rec,fuzzy fuz,checkpoint_time checkpoint from v$datafile_heade
natural join (select hxfil file#, fhsta, fhscn, fhrba_seq, fhafs from x$kcvfhall)
order by 1 ) ;

===================== Move pfile to spfile for the ASM ============================
SQL> show parameter spfile
asmcmd spget
gpnptool get -o-
create spfile='+DATA' from pfile='<path>/init+ASM1.ora';
How to Modify an Existing ASM Spfile in a RAC Environment (Doc ID 1376225.1)
================================ recycle bin===================
Select count(*) from sys.recyclebin$;
Truncate table sys.recyclebin$;
=========================== rpm install check ===============================================
rpm -qi 
=============================================================================================
--to delete flashback logs without downtime:
--check current space and limits
select space_used/(1024*1024*1024),space_limit/(1024*1024*1024) from v$recovery_file_dest;
--reduce the dest size 
alter system set db_recovery_file_dest_size=50G scope=both;
--it will remove old logs (check alert.log). Once completed, change back the dest size 
alter system set db_recovery_file_dest_size=400G scope=both; 
========================================  user session id ====================================================

SELECT SYS_CONTEXT ('USERENV', 'OS_USER') FROM DUAL;
SELECT SYS_CONTEXT ('USERENV', 'SID') FROM DUAL;

===================================== Restore database until scn =============================================
ou can use the below code in your environment:-
RMAN> connect target /
RMAN> startup mount;
RMAN> run{
set until scn <SCN of Interest>;
restore database;
recover database;
}
RMAN> alter database open resetlogs;
======================================== memlock /huge pages /shhmmax =====================================================================
egrep -i "shmmax|shmall|huge" /etc/sysctl.conf|grep -v "#"
grep vm.nr_hugepages /etc/sysctl.conf
grep memlock /etc/security/limits.conf


in /etc/sysctl.conf
shmmax = 9663676416
shmall = 2359296
vm.nr_hugepages = 4608

in /etc/security/limits.conf
oracle soft memlock 9437184
oracle hard memlock 9437184

genevabatchuser==========================================================

scp copy job:
=============

nohup scp tar.gz gasg@company.com:location > nohup.out 2>&1
Enter Password here: xxxx
Then press ctrl + z which will temporarily suspend the command, then enter the command
bg
jobs
==========================================================================================================================================

==================== Disable scheduler jobs ==================================================
Dynamic Query for DISABLE scheduler jobs
select 'execute dbms_scheduler.disable('||''''||OWNER||'.'||job_name||''''||'); ' from all_scheduler_jobs where ENABLED='TRUE';
After executing above if noticed any Running JOBS use below according to that Running JOB:
execute DBMS_SCHEDULER.stop_job (JOB_NAME => 'owner.<JOB_NAME>');

===============================================================================================
RAW disk ASM issues

 ls -ld /sys/block/vd*/device

===============================

select sys_context('userenv','sid'), sid from v$mystat where rownum=1;

select SYS_CONTEXT('USERENV','SID') from dual ;

-------------------------------------------------------------------------------
SID
----------
146
146
================================ check orabase =======================================

$ORACLE_HOME/bin/orabase

========================================== Huge pages  hugepages ============================================
hugepages:
egrep -i "shmmax|shmall|shmmni|huge" /etc/sysctl.conf|grep -v "#"
grep memlock /etc/security/limits.conf
==================================================================================================
How to Format Corrupted Block Not Part of Any Segment ( Doc ID 336133.1 ) 


================ Undo issues =============================================================
/* Max Query Length */
 select max(maxquerylen) from v$undostat;
 /* Tuned Undo Retention */
 SELECT MAX(TUNED_UNDORETENTION), MAX(MAXQUERYLEN), MAX(NOSPACEERRCNT), MAX(SSOLDERRCNT) FROM V$UNDOSTAT;
select CREATION_TIME,METRIC_VALUE, reason, suggested_action from DBA_ALERT_HISTORY where OBJECT_NAME = (SELECT UPPER(value) FROM v$parameter WHERE name = 'undo_tablespace');
select CREATION_TIME,METRIC_VALUE, reason, suggested_action from DBA_ALERT_HISTORY where OBJECT_NAME = (SELECT UPPER(value) FROM v$parameter WHERE name = 'undo_tablespace');


=====================================
1.) cvuqdisk-1.0.10-1
CVUQDISK_GRP=dba export CVUQDISK_GRP
rpm -iv cvuqdisk-1.0.10-1.rpm
location : - /opt/oracle/grid/19c/cv/rpm/cvuqdisk-1.0.10-1.rpm
==================================================================================
======================================================TOMS DM1 19c installation=========================================================
cd /u01/oracle/product/19c
initiate :  ./runInstaller -applyRU /u01/software/19c_softwares/PSU/DBPSU/33192793

====================================================================================

DBMS_AQ.DEQUEUE

EXEC dbms_aqadm.stop_time_manager;
EXEC dbms_lock.sleep(120); -- sleep is must
EXEC dbms_aqadm.start_time_manager;

====================================================================================


Fakhruddin Khadari / Shabuddin Khadri 
Jilani pasha / Ahemad pasha / Salahuddin / Pasha Begum
==============================Trace file ===========================================
vi script1.adr 
set home diag/rdbms/cgtomtr/CGTOMTR ; 
show alert -p "originating_timestamp > '2022-09-15 21:20:00' and originating_timestamp < '2022-09-16 05:10:00'" -term 

==================================================================================== GG check ==================
SELECT supplemental_log_data_min, force_logging FROM v$database;

======================== OS watcher process ===========================
ps -ef |grep oswbb

tfactl access lsusers
tfactl access promote -user oracle
tfactl access promote -user grid
tfactl access lsusers
=============================== Get index name ==============
set pagesize 132
set linesize 150
break on t_owner skip 1 on tabl skip 1 on i_owner on indx skip 1
column t_owner  format a12 heading 'Table|Owner' 
column tabl     format a29  heading 'Table'
column i_owner  format a12 heading 'Index|Owner'
column indx     format a29  heading 'Index'
column colum    format a29  heading 'Column'
column uniq     format a10  heading 'Unique'
select a.table_owner t_owner,
       a.table_name tabl,
       a.index_owner i_owner,
       a.index_name indx,
       a.column_name colum,
       b.uniqueness uniq
from dba_ind_columns a,
     dba_indexes b
where a.index_owner = b.owner
and   a.index_name = b.index_name
and   a.index_owner in ('RBM_CUSTOM')
and   a.index_name like 'CGBILLMESSAGE_PK'
order by a.table_owner,a.table_name,a.index_owner,a.index_name,
a.column_position;
================================ Rollback Segments ========================================

select name,string_value from ga.gprm
as of timestamp to_timestamp('2013-03-12 01:00:00', 'yyyy-mm-dd hh:mi:ss')
where name in ('xxx');

========================================= Partition Check=================================================

col SEGMENT_NAME for a28
col HIGH_VALUE for a22
col PARTITION_NAME for a18
select s.segment_name,p.PARTITION_NAME,p.HIGH_VALUE,p.PARTITION_POSITION, round(s.bytes/1024/1024/1024,3) "GB's", p.LAST_ANALYZED 
from dba_tab_partitions p, dba_segments s where p.TABLE_NAME='&NC_HISTORY' 
and p.partition_name=s.partition_name order by s.segment_name, p.PARTITION_POSITION;

======================================exclude drop partition in gg====================================================================
EXCLUDE OBJNAME GA.Costed OPTYPE ALTER INSTR 'DROP PARTITION' 
========================= Unistall afd ==================
https://docs.oracle.com/en/database/oracle/oracle-database/21/ostmg/administer-filter-driver.html#GUID-6AABD466-CC4D-4D17-92DB-42D65FB713F2
================================= DATAPUMP JOB ========================
SET LINESIZE 200

COLUMN owner_name FORMAT A20
COLUMN job_name FORMAT A30
COLUMN operation FORMAT A10
COLUMN job_mode FORMAT A10
COLUMN state FORMAT A12

SELECT owner_name,
       job_name,
       TRIM(operation) AS operation,
       TRIM(job_mode) AS job_mode,
       state,
       degree,
       attached_sessions,
       datapump_sessions
FROM   dba_datapump_jobs where state='EXECUTING'
ORDER BY 1, 2;
=======================================================================

Select sequence# from v$archived_log where 377637308320 is between first_change# and next_change#; 

=============================== Enable Quequ for ================================

SELECT name, enqueue_enabled, dequeue_enabled FROM dba_queues where owner='GA' and name='COLLECTIONQUEUE1';

exec dbms_aqadm.start_queue(queue_name =>'GA.COLLECTIONQUEUE1');

select count(*),msg_state from GA.COLLECTIONQUEUE1 group by msg_state ;

SELECT name, enqueue_enabled, dequeue_enabled
FROM dba_queues where name='COLLECTIONQUEUE1';


SELECT queue_name, queue_table, consumer_name, protocol, delivery_mode, queue_to_queue
FROM dba_queue_subscribers;

Below is the query to check backlog queues. Here “READY” count should be zero or less . 
select count(*),msg_state,consumer_name from GA.AQ$COLLECTIONQUEUE1 group by msg_state,consumer_name;

select owner_instance, primary_instance from DBA_QUEUE_TABLES where owner = 'GA' and queue_table='COLLECTIONQUEUE1';

exec dbms_aqadm.alter_queue_table(Queue_table => 'GA.COLLECTIONQUEUE1',primary_instance => 1,secondary_instance => 2);

======================================= Block Corruption ===========================================
col corruption_change# format 999999999999

select file#,block#,corruption_change#,corruption_type
from v$database_block_corruption;

select segment_name, segment_type
from dba_extents
where file_id = 2
and 340661 between block_id and ((block_id + blocks) - 1);



set lines 200 pages 10000
col segment_name format a30

SELECT e.owner, e.segment_type, e.segment_name, e.partition_name, c.file#
, greatest(e.block_id, c.block#) corr_start_block#
, least(e.block_id+e.blocks-1, c.block#+c.blocks-1) corr_end_block#
, least(e.block_id+e.blocks-1, c.block#+c.blocks-1)
- greatest(e.block_id, c.block#) + 1 blocks_corrupted
, null description
FROM dba_extents e, v$database_block_corruption c
WHERE e.file_id = c.file#
AND e.block_id <= c.block# + c.blocks - 1
AND e.block_id + e.blocks - 1 >= c.block#
UNION
SELECT s.owner, s.segment_type, s.segment_name, s.partition_name, c.file#
, header_block corr_start_block#
, header_block corr_end_block#
, 1 blocks_corrupted
, 'Segment Header' description
FROM dba_segments s, v$database_block_corruption c
WHERE s.header_file = c.file#
AND s.header_block between c.block# and c.block# + c.blocks - 1
UNION
SELECT null owner, null segment_type, null segment_name, null partition_name, c.file#
, greatest(f.block_id, c.block#) corr_start_block#
, least(f.block_id+f.blocks-1, c.block#+c.blocks-1) corr_end_block#
, least(f.block_id+f.blocks-1, c.block#+c.blocks-1)
- greatest(f.block_id, c.block#) + 1 blocks_corrupted
, 'Free Block' description
FROM dba_free_space f, v$database_block_corruption c
WHERE f.file_id = c.file#
AND f.block_id <= c.block# + c.blocks - 1
AND f.block_id + f.blocks - 1 >= c.block#
ORDER BY file#, corr_start_block#;



COLUMN owner FORMAT A20
COLUMN segment_name FORMAT A30

SELECT DISTINCT owner, segment_name
FROM   v$database_block_corruption dbc
       JOIN dba_extents e ON dbc.file# = e.file_id AND dbc.block# BETWEEN e.block_id and e.block_id+e.blocks-1
ORDER BY 1,2;


============================ datafile usage =======
SET PAUSE ON
SET PAUSE 'Press Return to Continue'
SET PAGESIZE 60
SET LINESIZE 300
COLUMN "Tablespace Name" FORMAT A20
COLUMN "File Name" FORMAT A80
 
SELECT  Substr(df.tablespace_name,1,20) "Tablespace Name",
        Substr(df.file_name,1,80) "File Name",
        Round(df.bytes/1024/1024,0) "Size (M)",
        decode(e.used_bytes,NULL,0,Round(e.used_bytes/1024/1024,0)) "Used (M)",
        decode(f.free_bytes,NULL,0,Round(f.free_bytes/1024/1024,0)) "Free (M)",
        decode(e.used_bytes,NULL,0,Round((e.used_bytes/df.bytes)*100,0)) "% Used"
FROM    DBA_DATA_FILES DF,
       (SELECT file_id,
               sum(bytes) used_bytes
        FROM dba_extents
        GROUP by file_id) E,
       (SELECT sum(bytes) free_bytes,
               file_id
        FROM dba_free_space
        GROUP BY file_id) f
WHERE    e.file_id (+) = df.file_id
and DF.file_id=&datafile_id
AND      df.file_id  = f.file_id (+)
ORDER BY df.tablespace_name,
         df.file_name
/
===========================  Database Patch  ==================
select patch_id,status,description from dba_registry_sqlpatch; 
==============================  file access =================================
fuser == to check access of user

========================  SDO Component installation steps: =================================


select comp_id,COMP_NAME,status from dba_registry where comp_id in ('ORDIM','SDO') order by comp_id; -> if SDO not present

sqlplus / as sysdba

@invalid_obj_check

@?/md/admin/mdinst.sql

select comp_id,COMP_NAME,status from dba_registry where comp_id in ('ORDIM','SDO') order by comp_id;

@invalid_obj_check

@?/rdbms/admin/utlrp.sql

@invalid_obj_check
========================== Locked objects ============================================
set lines 200 pages 300
col OWNER for a15
col OBJECT_NAME for a30
col OSUSER for a15
col MACHINE for a40
col OBJECT_TYPE for a15

select
   c.owner,
   c.object_name,
   c.object_type,
   b.sid,
   b.serial#,
   b.status,
   b.osuser,
   b.machine
from
   v$locked_object a ,
   v$session b,
   dba_objects c
where
   b.sid = a.session_id
and
   a.object_id = c.object_id;
   
=====================================================================

Proxy user creation :
sqlplus / as sysdba
create user Test identified by Test default tablespace USERS temporary tablespace TEMP;
grant connect, resource to Test;
select USERNAME,DEFAULT_TABLESPACE,TEMPORARY_TABLESPACE,PROFILE from dba_users where username='Test';
alter user application_user grant connect through Test;
connect Test[application_user]/Test@company.com:1521/service

=======================================================================
==================Table Truncated information ==========
 select * from mytab as of timestamp TO_TIMESTAMP('20121230 09:29:24','yyyymmdd hh24:mi:ss');
 ========================================== datapatch verbose locations =================
 
 Datapatch failed with "catconInit failed with 1" (Doc ID 2879072.1)	
 $ORACLE_BASE/cfgtoollogs/sqlpatch/
 ============================
 
 gather stats for sys, dictionary tables, fixed objects

alter session set nls_date_format='YYYY-Mon-DD';
col last_analyzed for a13
set termout off
set trimspool off
set feedback off
prompt 'Statistics for SYS tables'
SELECT NVL(TO_CHAR(last_analyzed, 'YYYY-Mon-DD'), 'NO STATS') last_analyzed, COUNT(*) dictionary_tables
FROM dba_tables
WHERE owner = 'SYS'
GROUP BY TO_CHAR(last_analyzed, 'YYYY-Mon-DD')
ORDER BY 1 DESC;




Cell (760) 814-7247


GCI-50783- [GCI Polaris]  BF - Install Sprint 23.04 to Breakfix  (Preprod)

  CSV FILE generated ======
  set colsep ,
set pages 5000
set lines 32767
==========================
select count(*) from owner.table as of timestamp to_timestamp('2022/12/16 03:30:00 AM', 'yyyy/mm/dd:hh:mi:ss AM');
================================
Some Physical standby lag check sql's

================================================================================================================================================================
LAG CHECK:

SELECT ARCH.THREAD# "Thread", ARCH.SEQUENCE# "Last Sequence Received", APPL.SEQUENCE# "Last Sequence Applied", (ARCH.SEQUENCE# - APPL.SEQUENCE#) "Difference"
FROM
(SELECT THREAD# ,SEQUENCE# FROM V$ARCHIVED_LOG WHERE (THREAD#,FIRST_TIME ) IN
(SELECT THREAD#,MAX(FIRST_TIME) FROM V$ARCHIVED_LOG GROUP BY THREAD#)) ARCH,
(SELECT THREAD# ,SEQUENCE# FROM V$LOG_HISTORY WHERE (THREAD#,FIRST_TIME ) IN
(SELECT THREAD#,MAX(FIRST_TIME) FROM V$LOG_HISTORY GROUP BY THREAD#)) APPL
WHERE
ARCH.THREAD# = APPL.THREAD#;
================================================================================================================================================================
Verify the last sequence# received and the last sequence# applied to standby database.

SELECT al.thrd "Thread", almax "Last Seq Received", lhmax "Last Seq Applied" FROM (select thread# thrd, MAX(sequence#) almax FROM v$archived_log WHERE resetlogs_change#=(SELECT resetlogs_change# FROM v$database) GROUP BY thread#) al, (SELECT thread# thrd, MAX(sequence#) lhmax FROM v$log_history WHERE resetlogs_change#=(SELECT resetlogs_change# FROM v$database) GROUP BY thread#) lh WHERE al.thrd = lh.thrd;
Thread Last Seq Received Last Seq Applied
================================================================================================================================================================
To check the log status:

select 'Last Log applied : ' Logs, to_char(next_time,'DD-MON-YY:HH24:MI:SS') Time
from v$archived_log
where sequence# = (select max(sequence#) from v$archived_log where applied='YES')
union
select 'Last Log received : ' Logs, to_char(next_time,'DD-MON-YY:HH24:MI:SS') Time
from v$archived_log
where sequence# = (select max(sequence#) from v$archived_log);
================================================================================================================================================================
To find last applied log
select to_char(max(FIRST_TIME),'hh24:mi:ss dd/mm/yyyy') FROM V$ARCHIVED_LOG where applied='YES';
================================================================================================================================================================
set lines 132
col value format a20
select name, value from V$DATAGUARD_STATS;

======================================================================================================================
scn at timestamp

column SCN format 999999999999999
select timestamp_to_scn(to_timestamp('15-05-2023 22:52:00','dd-mm-yyyy hh24:mi:ss')) scn from dual;



Mailx Configurations :
mailx -s "$(echo "GG REPORT \nContent-Type: text/html")" gaziPasha.shaikh@company.com < log.log

OR

# create a header file
$ cat mailheader
To: user@gmail.com
Subject: my subject
Content-Type: text/html

# send
$ cat mailheader email.html | sendmail -t
==================
Check TOP Tables sizes
TABLES:

col SEGMENT_NAME for a25
select  * from (select  owner, segment_name, bytes/1024/1024/1024 "GB's" from dba_segments where segment_type = 'TABLE' order by  bytes/1024/1024/1024 desc) where rownum <= 10;

INDEXES:

col SEGMENT_NAME for a25
select  * from (select  owner, segment_name, bytes/1024/1024/1024 "GB's" from dba_segments where segment_type = 'INDEX' order by  bytes/1024/1024/1024 desc) where rownum <= 10;

CHECK IF TABLE HAS PARTITION
select partitioned from dba_tables where table_name='&TABLE_NAME';

CHECK which TABLESPACE BELONGS
select segment_name,tablespace_name from dba_segments where segment_name='&TABLE_NAME';

select index_name,status from dba_indexes where table_name='&TABLE_NAME';

if table has no rows 

select count(*) from &TABLE_NAME;

Move the table to USERS and move it back to original tablespace.

alter table &TABLE_NAME move tablespace users;
alter table &TABLE_NAME move tablespace RB_DATA

rebuild indexes corrosponding to tables.

alter index &INDEX_NAME rebuild;   Will come out quickly.

col SEGMENT_NAME for a25
select  * from (select  owner, segment_name, bytes/1024/1024/1024 "GB's" from dba_segments where segment_type = 'TABLE' order by  bytes/1024/1024/1024 desc) where rownum <= 10;

col SEGMENT_NAME for a25
select  * from (select  owner, segment_name, bytes/1024/1024/1024 "GB's" from dba_segments where segment_type = 'INDEX' order by  bytes/1024/1024/1024 desc) where rownum <= 10;
================================================= GG COMMANDS ========
1. Stop Extractor force stop 
SEND EXTRACT EXTTOMS,FORCESTOP  
==========================
remover after coma
Remove everything after command vi editor 
1,$s/,.*//g

======================================= Oracle Multimedia/Oracle Locator/SDO ===========================
a. TO Check ORACLE MultiMedia Component used or not  .

To determine if Oracle Multimedia objects types are used in any tables, the following query can be used .

select count(u.table_name) from
    sys.dba_tab_columns u
    where u.table_name not in (select object_name from sys.dba_recyclebin)
       and u.data_type IN
            ('ORDIMAGE','ORDIMAGESIGNATURE','ORDAUDIO','ORDVIDEO',
             'ORDDOC','ORDSOURCE','ORDDICOM','ORDDATASOURCE',
             'SI_STILLIMAGE','SI_COLOR','SI_AVERAGECOLOR',
             'SI_POSITIONALCOLOR','SI_TEXTURE','SI_COLORHISTOGRAM',
             'SI_FEATURELIST')
         and (u.data_type_owner IN ('ORDSYS', 'PUBLIC'))
         and (u.owner <> 'PM');
		 
It is possible to use Oracle Multimedia without using the object types.  
In order to determine if Oracle Multimedia packages are being used, source code must be searched for calls to the following packages:

ORDSYS.ORDAUDIO
ORDSYS.ORD_AUDIO
ORDSYS.ORDDICOM
ORDSYS.ORD_DICOM
ORDSYS.ORD_DICOM_ADMIN
ORDSYS.ORDDOC
ORDSYS.ORD_DOC
ORDSYS.ORDIMAGE
ORDSYS.ORD_IMAGE
ORDSYS.ORDVIDEO
ORDSYS.ORD_VIDEO

==========================================================
To check ORACLE SDO componenet is used or not .

col owner format a12
col table_name format a35
col column_name format a25
select owner, table_name, column_name from dba_tab_columns where data_type = 'SDO_GEOMETRY'
and owner != 'MDSYS';
==============================
AMM    -> Hugepages not to set
======
MEMORY_TARGET
MEMORY_MAX_TARGET

ASMM   -> Hugepages can be setup
===========
SGA_TARGET
SGA_MAX_TARGET
PGA_AGGREGATE_TARGET
====================== FRA Size =============
select 
                NAME, 
                round((SPACE_LIMIT - SPACE_USED)/POWER(1024,3)) FREE,
                round(SPACE_RECLAIMABLE/POWER(1024,3)) RECLAIMABLE,
                round(SPACE_LIMIT/POWER(1024,3)) TOTAL, 
                round(((SPACE_USED - SPACE_RECLAIMABLE)/POWER(1024,3))*100/(SPACE_LIMIT/POWER(1024,3))) UTL 
        from V$RECOVERY_FILE_DEST ;
================================================
patching Docs -1454618.1 
==============How to install and deinstall Oracle Spatial and Oracle Multimedia=====================================================
The following advice is an excerpt from a Service Request with Oracle support services, on how to administer Spatial and Multimedia:

To remove Spatial:
connect / as sysdba 
 drop user MDSYS cascade; 
To remove Multimedia:
connect / as sysdba 
 @?/rdbms/admin/catcmprm.sql ORDIM 
You can reinstall both of these components later if needed by running the following scripts. Note, Multimedia must be installed first.

To Install Multimedia:
connect / as sysdba 
 @?/ord/admin/ordinst.sql SYSAUX SYSAUX 
 @?/ord/im/admin/catim.sql 
 execute sys.validate_ordim; 
To install Spatial:
connect / as sysdba 
 @?/md/admin/mdinst.sql 
=================================db_link db link ===============

		 col OWNER for a30
         col DB_LINK for 30
         col USERNAME for a20
         col HOST for a60
         select OWNER,DB_LINK,USERNAME,HOST from dba_db_links;
		 
===================================blocking session / holder =============================

set serveroutput on 
set feedback off 
set linesize 300 
 
declare 
blockcount number; 
sqlreport varchar(3000); 
sqloutput varchar(5000); 
v_rec varchar(3000); 
 
cursor blk_curs is select B.USERNAME BUSER,B.SID BSID,B.SERIAL# BSERIAL,B.INST_ID BID,B.STATUS BSTAT,B.LAST_CALL_ET BLAST,W.USERNAME WUSER,W.SID WSID,W.SERIAL# WSERIAL,W.INST_ID WID  
from (select INST_ID,SID,SERIAL#,USERNAME,STATUS,BLOCKING_INSTANCE,BLOCKING_SESSION, LAST_CALL_ET from gv$session where BLOCKING_SESSION >0) W,  
(select INST_ID,SID,SERIAL#,USERNAME,STATUS,LAST_CALL_ET from gv$session ) B  
where W.BLOCKING_INSTANCE=B.INST_ID and W.BLOCKING_SESSION=B.SID and B.username not in ('SYS','SYSTEM','DBSNMP','RMAN'); 
cursor distval is select distinct B.SID CSID, B.USERNAME CUSER from (select INST_ID,SID,SERIAL#,USERNAME,STATUS,BLOCKING_INSTANCE,BLOCKING_SESSION, LAST_CALL_ET  
from gv$session where BLOCKING_SESSION >0) W, (select INST_ID,SID,SERIAL#,USERNAME,STATUS,LAST_CALL_ET from gv$session ) B  
where W.BLOCKING_INSTANCE=B.INST_ID and W.BLOCKING_SESSION=B.SID and B.username not in ('SYS','SYSTEM','DBSNMP','RMAN'); 
cursor killcurs(v in varchar, b in number) is select SID ,serial# SERIAL,inst_id ,username ,to_char(logon_time,'''DD-MON-YYYY HH24-MI-SS''') OTIME,event,status ,machine ,round(LAST_CALL_ET/60,2) OMIN  
FROM gv$session where username is not null and username=v and sid=b order by inst_id; 
begin 
DBMS_OUTPUT.put_line('Checking for blocking sessions on this database'); 
DBMS_OUTPUT.put_line('-----------------------------------------------');
select count(*) into blockcount from (select * from gv$session where BLOCKING_SESSION >0) W, 
(select * from gv$session ) B where W.BLOCKING_INSTANCE=B.INST_ID and W.BLOCKING_SESSION=B.SID and B.username not in ('SYS','SYSTEM','DBSNMP','RMAN'); 
    IF blockcount > 0 THEN 
        DBMS_OUTPUT.put_line('Found blocking sessions -> Fetching report for the same'); 
        DBMS_OUTPUT.put_line('-------------------------------------------------------'); 
        for v_rec in blk_curs LOOP 
        dbms_output.put_line(v_rec.BUSER ||' ('||v_rec.BSID||','||v_rec.BSERIAL||',@'||v_rec.BID||') is Currently '||v_rec.BSTAT||' for last '||v_rec.BLAST||' Sec and it''s BLOCKING user '|| v_rec.WUSER||' ('||v_rec.WSID||','||v_rec.WSERIAL||',@'||v_rec.WID||')'); 
        end loop; 
        DBMS_OUTPUT.put_line('-'); 
        DBMS_OUTPUT.put_line('-'); 
        DBMS_OUTPUT.put_line('Further details on blocking sessions -> includes kill script of blocking session'); 
        DBMS_OUTPUT.put_line('--------------------------------------------------------------------------------'); 
        for v_rec2 in distval LOOP 
            for v_rec3 in killcurs(v_rec2.CUSER, v_rec2.CSID) loop 
            dbms_output.put_line('alter system kill session '''||v_rec3.SID|| ',' || v_rec3.SERIAL||',@'||v_rec3.inst_id|| ''' immediate; '||v_rec3.username||' '||v_rec3.OTIME||' '|| v_rec3.event||' '||v_rec3.status||' '||v_rec3.machine||' '||v_rec3.OMIN); 
            end loop; 
        end loop; 
        DBMS_OUTPUT.put_line('-'); 
        DBMS_OUTPUT.put_line('-'); 
    ELSE 
        DBMS_OUTPUT.put_line('-'); 
        DBMS_OUTPUT.put_line('-'); 
        DBMS_OUTPUT.put_line('Hurrey !!! No blocking sessions found'); 
        DBMS_OUTPUT.put_line('-'); 
        DBMS_OUTPUT.put_line('-'); 
    END IF; 
END; 
/
=============================to check db timezone ====
sELECT SESSIONTIMEZONE, DBTIMEZONE FROM DUAL;
========================================== to find dbms jobs database_role attribute value ============

SET SERVEROUTPUT ON
DECLARE
get_name VARCHAR2 (50);
v_value VARCHAR2 (50);
get_attribute VARCHAR2 (50);
BEGIN
get_name := 'RTE_READER_JOB';
get_attribute := 'DATABASE_ROLE';
DBMS_SCHEDULER.get_attribute (name => get_name,
attribute => get_attribute,
VALUE => v_value);
DBMS_OUTPUT.put_line (get_name || ' = ' || v_value);
END;
/

======================================================================================================


https://stackoverflow.com/questions/41796466/ansible-playbook-to-execute-oracle-script

==============================AWR - SNAPSHOT =========================================================
select snap_interval, retention from dba_hist_wr_control;
To create a manual snapshot:

exec dbms_workload_repository.create_snapshot;

To change retention and interval :
exec dbms_workload_repository.modify_snapshot_settings(interval => 15, retention => 44640) ;

SELECT occupant_name, schema_name, move_procedure, space_usage_kbytes FROM v$sysaux_occupants ORDER BY 1;
===================archive generation by session ==========
This Query is to find the session that is generating more Archives.
col program for a10
col username for a10
select to_char(sysdate,’hh24:mi’), username, program , a.sid, a.serial#, b.name, c.value
from v$session a, v$statname b, v$sesstat c
where b.STATISTIC# =c.STATISTIC#
and c.sid=a.sid and b.name like ‘redo%’
order by value
===========================================================

Uncommited trasaction ===========
set lines 250
column start_time format a20
column sid format 99999
column serial# format 999999
column username format a10
column status format a10
column schemaname format a10
select t.start_time,s.sid,s.serial#,s.username,s.status,s.schemaname,
s.osuser,s.process,s.machine,s.terminal,s.program,s.module,to_char(s.logon_time,'DD/MON/YY HH24:MI:SS') logon_time
from v$transaction t, v$session s
where s.saddr = t.ses_addr
order by start_time;

for perticular sid 

set lines 250
column start_time format a20
column sid format 99999
column serial# format 999999
column username format a10
column status format a10
column schemaname format a10
select t.start_time,s.sid,s.serial#,s.username,s.status,s.schemaname,
s.osuser,s.process,s.machine,s.terminal,s.program,s.module,to_char(s.logon_time,'DD/MON/YY HH24:MI:SS') logon_time
from v$transaction t, v$session s
where s.saddr = t.ses_addr
and s.sid=&sid
order by start_time;

================================= Audit information=========================
/etc/rsyslog.conf 

relocate scan==============
srvctl status scan_listener
srvctl relocate scan_LISTENER -i 1 -n node2
===================================================
select s.sid, t.sql_text
from v$session s, v$sql t
where s.event like '%mutex%'
and t.sql_id = s.sql_id


SELECT sql_text FROM v$sqltext WHERE address = '&addr' ORDER BY piece;

==============================CDC SCRIPTS ===========================================================
select scn_to_timestamp(4426538972) as timestamp from dual;

CDC Capture

select set_name, CAPTURE_NAME,QUEUE_NAME,APPLY_NAME,ADVANCE_ENABLED from all_change_sets where ADVANCE_ENABLED <> 'Y';

start CDC capture
BEGIN
DBMS_CAPTURE_ADM.START_CAPTURE(capture_name => 'CDC$C_L00004_CS_HOTLOG');
END;
/

APPLY COMMAND:

BEGIN
DBMS_APPLY_ADM.START_APPLY(apply_name => 'CDC$C_L00004_CS_HOTLOG');
END;
/
====================================== SQL Tune report ================================
set lines 300 long 1000000 longchunksize 10000000 pages 5000 verify off
select dbms_sqltune.report_sql_monitor('&sql_id',type=>'TEXT',report_level=>'ALL') FROM DUAL;
=======================================================================================


GG Pre-requisites
exec dbms_goldengate_auth.grant_admin_privilege ('GG USER');


NAS partition /files system / mount point
grep nfs /etc/fstab

=====================================Sticky Bit permission ==================================================
In Customer environment "Stick bit" [s] is missing.

oracle@ora-gsw-001:/sw/oracle/bin> ls -lrt oradism
-rwxr-x--- 1 root dba 147848 abr 17 2019 oradism>>>>>>>>>>>>>>> Incorrect one with missing stick bit "s"
From root user:

# chmod u+s oradism
=============================================== Socket Files deleted ==================
Oracle Linux 7 and Redhat Linux 7: The socket files in /var/tmp/.oracle Location Get Deleted (Doc ID 2455193.1)
To exclude the socket files in a tmp directory from getting deleted by the tempfile clean service, change the content of /usr/lib/tmpfiles.d/tmp.conf and add

x /tmp/.oracle*
x /var/tmp/.oracle*
x /usr/tmp/.oracle*
The "x" option above indicates to the systemd-tmpfiles-clean.service to exclude files in the listed directory.

====================================================================================================
check error in listner log file 

 grep "24-MAR" /opt/oracle/diag/tnslsnr/stagedevdb2/listener/trace/listener.log | awk  '{ if ( $NF != 0 ) print $0 }'
 
 
 Cluster patch version ==============================================================================
crsctl query crs activeversion -f
crsctl query crs softwareversion
crsctl query crs releasepatch    --- check cluster patch version

 CRSCTL QUERY CRS SOFTWAREPATCH [NODE_NAME]
 CRSCTL QUERY CRS SOFTWAREVERSION [NODE_NAME]
 ============================ Materialized sys review ===============================================================================================
 SELECT owner, mview_name, last_refresh_date  FROM dba_mviews  WHERE owner = 'CGTMP_7000'   AND mview_name = 'AT_RBM_ACCOUNTS_MV'   ;

col OWNER for A30
col JOB_NAME for A30
col JOB_ACTION for A30
col REPEAT_INTERVAL for A30
col STATE for A30
col LAST_START_DATE for A30
col NEXT_RUN_DATE for A30
select OWNER,JOB_NAME,JOB_ACTION,REPEAT_INTERVAL,STATE,LAST_START_DATE,NEXT_RUN_DATE,MAX_RUN_DURATION from dba_SCHEDULER_JOBS where JOB_NAME like '%&name%' ;
======================================================================================================================================================

export LD_LIBRARY_PATH=$ORACLE_HOME/lib


=============================to print echo on sql script===========
set serveroutput on size unlimited;
exec DBMS_OUTPUT.ENABLE (buffer_size => NULL);
set echo on
=============================  Tablespace space forcasted growth / Tablespace growth  ========================================================
set serverout on
set verify off
set lines 200
set pages 2000
DECLARE
v_ts_id number;
not_in_awr EXCEPTION;
v_con_id number;
par_con_id number;
v_con_name varchar2(20);
v_ts_block_size number;
v_begin_snap_id number;
v_end_snap_id number;
v_begin_snap_date date;
v_end_snap_date date;
v_numdays number;
v_ts_begin_size number;
v_ts_end_size number;
v_ts_growth number;
v_count number ;
v_ts_begin_allocated_space number;
v_ts_end_allocated_space number;
cursor v_con_cur is select con_id, name from v$containers where name <> 'PDB$SEED';
cursor v_ts_cur(par_con_id number) is select tablespace_name from cdb_tablespaces where contents='PERMANENT' and con_id = par_con_id;

BEGIN
FOR v_con_rec in v_con_cur
LOOP
DBMS_OUTPUT.PUT_LINE(CHR(10));
DBMS_OUTPUT.PUT_LINE('Container = '||v_con_rec.name);
DBMS_OUTPUT.PUT_LINE('====================');
FOR v_ts_rec in v_ts_cur(v_con_rec.con_id)
LOOP
BEGIN
SELECT ts# into v_ts_id FROM v$tablespace where name = v_ts_rec.tablespace_name and con_id= v_con_rec.con_id;
SELECT count(*) INTO v_count FROM dba_hist_tbspc_space_usage where tablespace_id=v_ts_id and con_id= v_con_rec.con_id;
IF v_count = 0 THEN
RAISE not_in_awr;
END IF ;

SELECT block_size into v_ts_block_size FROM cdb_tablespaces where tablespace_name = v_ts_rec.tablespace_name and con_id= v_con_rec.con_id;
SELECT min(snap_id), max(snap_id), min(trunc(to_date(rtime,'MM/DD/YYYY HH24:MI:SS'))), max(trunc(to_date(rtime,'MM/DD/YYYY HH24:MI:SS')))
into v_begin_snap_id,v_end_snap_id, v_begin_snap_date, v_end_snap_date from dba_hist_tbspc_space_usage where tablespace_id=v_ts_id and con_id= v_con_rec.con_id;
v_numdays := v_end_snap_date - v_begin_snap_date;

SELECT round(max(tablespace_size)*v_ts_block_size/1024/1024,2) into v_ts_begin_allocated_space from dba_hist_tbspc_space_usage where tablespace_id=v_ts_id and con_id= v_con_rec.con_id and snap_id = v_begin_snap_id;
SELECT round(max(tablespace_size)*v_ts_block_size/1024/1024,2) into v_ts_end_allocated_space from dba_hist_tbspc_space_usage where tablespace_id=v_ts_id and con_id= v_con_rec.con_id and snap_id = v_end_snap_id;
SELECT round(max(tablespace_usedsize)*v_ts_block_size/1024/1024,2) into v_ts_begin_size from dba_hist_tbspc_space_usage where tablespace_id=v_ts_id and con_id= v_con_rec.con_id and snap_id = v_begin_snap_id;
SELECT round(max(tablespace_usedsize)*v_ts_block_size/1024/1024,2) into v_ts_end_size from dba_hist_tbspc_space_usage where tablespace_id=v_ts_id and con_id= v_con_rec.con_id  and snap_id = v_end_snap_id;
v_ts_growth := v_ts_end_size - v_ts_begin_size;
DBMS_OUTPUT.PUT_LINE(CHR(10));
DBMS_OUTPUT.PUT_LINE(v_ts_rec.tablespace_name||' Tablespace');
DBMS_OUTPUT.PUT_LINE('--------------------');
DBMS_OUTPUT.PUT_LINE('Tablespace Block Size: '||v_ts_block_size);
DBMS_OUTPUT.PUT_LINE('---------------------------');
DBMS_OUTPUT.PUT_LINE(CHR(10));
DBMS_OUTPUT.PUT_LINE('Summary');
DBMS_OUTPUT.PUT_LINE('========');
DBMS_OUTPUT.PUT_LINE('1) Allocated Space: '||v_ts_end_allocated_space||' MB'||' ('||round(v_ts_end_allocated_space/1024,2)||' GB)');
DBMS_OUTPUT.PUT_LINE('2) Used Space: '||v_ts_end_size||' MB'||' ('||round(v_ts_end_size/1024,2)||' GB)');
DBMS_OUTPUT.PUT_LINE('3) Used Space Percentage: '||round(v_ts_end_size/v_ts_end_allocated_space*100,2)||' %');
DBMS_OUTPUT.PUT_LINE(CHR(10));
DBMS_OUTPUT.PUT_LINE('History');
DBMS_OUTPUT.PUT_LINE('========');
DBMS_OUTPUT.PUT_LINE('1) Allocated Space on '||v_begin_snap_date||': '||v_ts_begin_allocated_space||' MB'||' ('||round(v_ts_begin_allocated_space/1024,2)||' GB)');
DBMS_OUTPUT.PUT_LINE('2) Current Allocated Space on '||v_end_snap_date||': '||v_ts_end_allocated_space||' MB'||' ('||round(v_ts_end_allocated_space/1024,2)||' GB)');
DBMS_OUTPUT.PUT_LINE('3) Used Space on '||v_begin_snap_date||': '||v_ts_begin_size||' MB'||' ('||round(v_ts_begin_size/1024,2)||' GB)' );
DBMS_OUTPUT.PUT_LINE('4) Current Used Space on '||v_end_snap_date||': '||v_ts_end_size||' MB'||' ('||round(v_ts_end_size/1024,2)||' GB)' );
DBMS_OUTPUT.PUT_LINE('5) Total growth during last '||v_numdays||' days between '||v_begin_snap_date||' and '||v_end_snap_date||': '||v_ts_growth||' MB'||' ('||round(v_ts_growth/1024,2)||' GB)');
IF (v_ts_growth <= 0 OR v_numdays <= 0) THEN
DBMS_OUTPUT.PUT_LINE(CHR(10));
DBMS_OUTPUT.PUT_LINE('!!! NO DATA GROWTH WAS FOUND FOR THIS TABLESPACE !!!');
ELSE
DBMS_OUTPUT.PUT_LINE('6) Per day growth during last '||v_numdays||' days: '||round(v_ts_growth/v_numdays,2)||' MB'||' ('||round((v_ts_growth/v_numdays)/1024,2)||' GB)');
DBMS_OUTPUT.PUT_LINE(CHR(10));
DBMS_OUTPUT.PUT_LINE('Expected Growth');
DBMS_OUTPUT.PUT_LINE('===============');
DBMS_OUTPUT.PUT_LINE('1) Expected growth for next 30 days: '|| round((v_ts_growth/v_numdays)*30,2)||' MB'||' ('||round(((v_ts_growth/v_numdays)*30)/1024,2)||' GB)');
DBMS_OUTPUT.PUT_LINE('2) Expected growth for next 60 days: '|| round((v_ts_growth/v_numdays)*60,2)||' MB'||' ('||round(((v_ts_growth/v_numdays)*60)/1024,2)||' GB)');
DBMS_OUTPUT.PUT_LINE('3) Expected growth for next 90 days: '|| round((v_ts_growth/v_numdays)*90,2)||' MB'||' ('||round(((v_ts_growth/v_numdays)*90)/1024,2)||' GB)');
END IF;

EXCEPTION
WHEN NOT_IN_AWR THEN
DBMS_OUTPUT.PUT_LINE(CHR(10));
DBMS_OUTPUT.PUT_LINE(v_ts_rec.tablespace_name||' Tablespace');
DBMS_OUTPUT.PUT_LINE('--------------------');
DBMS_OUTPUT.PUT_LINE('Tablespace Block Size: '||v_ts_block_size);
DBMS_OUTPUT.PUT_LINE('---------------------------');
DBMS_OUTPUT.PUT_LINE(CHR(10));
DBMS_OUTPUT.PUT_LINE('!!! TABLESPACE USAGE INFORMATION NOT FOUND IN AWR !!!');
NULL;
END;
END LOOP;
DBMS_OUTPUT.PUT_LINE('/\/\/\/\/\/\/\/\/\/\/\/ END \/\/\/\/\/\/\/\/\/\/\/\');
END LOOP;
END;
/


with t as (
select ss.run_time,ts.name,round(su.tablespace_size*dt.block_size/1024/1024/1024,2) alloc_size_gb,
round(su.tablespace_usedsize*dt.block_size/1024/1024/1024,2) used_size_gb
from
dba_hist_tbspc_space_usage su,
(select trunc(BEGIN_INTERVAL_TIME) run_time,max(snap_id) snap_id from dba_hist_snapshot
group by trunc(BEGIN_INTERVAL_TIME) ) ss,
v$tablespace ts,
dba_tablespaces dt
where su.snap_id = ss.snap_id
and su.tablespace_id = ts.ts#
and ts.name in ('UNDOTBS1')
and ts.name = dt.tablespace_name )
select e.run_time,e.name,e.alloc_size_gb,e.used_size_gb curr_used_size_gb,b.used_size_gb prev_used_size_gb, (e.used_size_gb - b.used_size_gb) as variance
from t e, t b
where e.run_time = b.run_time + 1
order by 1;


======================================================================================================================

check view on table 
DBA_DEPENDENCIES
======================= Golden gater Initial Load ===============
syn the gg first .


1. Table entry Source prm - Done
2. Add trandata  - Done
3. start extract done 
4. note SCN done
5. Start export with SCN -done
6. Import (Metadata +DATA)
7. Change rowID  - Done
8. New coulmn addition
9.Addition on table in prm files(SCN based)
10.start replicator
11. sync replicator
12.stop replicator
13.remove scn entry in prm file
14.start replicator . 
==============================================

Get DDl of Refrenece contraints 

SELECT DBMS_METADATA.GET_DEPENDENT_DDL('REF_CONSTRAINT','&table_name','&schema') from dual;

=============================check constraints ====================================
set pagesize 100
set linesize 300

break on owner on child on p_owner on parent on constraint_name
column owner heading 'Child|Owner'
column child heading 'Child|Table' FORMAT A25
column p_owner heading 'Parent|Owner'
column parent heading 'Parent|Table' FORMAT A25
column constraint_name heading 'Constraint|Name' FORMAT A25
column col_name heading 'Column|Name' FORMAT A25
column delete_rule heading 'Delete|Rule'

select   substr(c.owner,1,8) owner,
         substr(c.table_name,1,30) child,
         substr(p.owner,1,8) p_owner,
         substr(p.table_name,1,30) parent,
         substr(c.constraint_name,1,23) constraint_name,
         substr(x.column_name,1,25) col_name,
         substr(c.delete_rule,1,6) delete_rule
from     dba_constraints c,
         dba_constraints p,
         dba_cons_columns x
where    c.constraint_type = 'R'
and      c.r_owner = p.owner
and      c.r_constraint_name = p.constraint_name
and      c.constraint_name = x.constraint_name
and      c.owner = x.owner
--and      c.table_name = 'ACT_RU_INCIDENT'
--and      p.table_name = 'AAF_ROLE'
--and      c.owner like 'COLL_ADMIN'
and      c.constraint_name LIKE 'FK_COLL_CLLCTR_6'
order by c.owner,c.table_name,p.r_owner,p.table_name,c.constraint_name,x.position;
============================================Undo tablespace growth  forcast=============================================
with t as (
select ss.run_time,ts.name,round(su.tablespace_size*dt.block_size/1024/1024/1024,2) alloc_size_gb,
round(su.tablespace_usedsize*dt.block_size/1024/1024/1024,2) used_size_gb
from
dba_hist_tbspc_space_usage su,
(select trunc(BEGIN_INTERVAL_TIME) run_time,max(snap_id) snap_id from dba_hist_snapshot
group by trunc(BEGIN_INTERVAL_TIME) ) ss,
v$tablespace ts,
dba_tablespaces dt
where su.snap_id = ss.snap_id
and su.tablespace_id = ts.ts#
and ts.name in ('UNDOTBS1')
and ts.name = dt.tablespace_name )
select e.run_time,e.name,e.alloc_size_gb,e.used_size_gb curr_used_size_gb,b.used_size_gb prev_used_size_gb, (e.used_size_gb - b.used_size_gb) as variance
from t e, t b
where e.run_time = b.run_time + 1
order by 1;
==========================================================
How to Shrink the datafile of Undo Tablespace (Doc ID 268870.1)	

How to Resize the Undo Tablespace (Doc ID 1951696.1)	


alter database register or replace logfile '/oradata/arch/lpqa2/offline/lpqa21_arch_t1_s27506_r711984890.dbf';


13.06.2024 06:23:59 [ERROR] sql error: -54 ORA-00054: resource busy and acquire with NOWAIT specified or timeout expiredORA-06512: at "CGTMP_7000.PKG_DART", line 846
ORA-06512: at "CGTMP_7000.PKG_DART", line 846
13.06.2024 06:23:59 [ERROR] Moving the old report to history failed.


13.06.2024 06:23:59 [ERROR] sql error: -54 ORA-00054: resource busy and acquire with NOWAIT specified or timeout expiredORA-06512: at "CGTMP_7000.PKG_DART", line 846
ORA-06512: at "CGTMP_7000.PKG_DART", line 846
13.06.2024 06:23:59 [ERROR] Moving the old report to history failed.
================================== TEMP segment utilization /tempfile usage/
Good query . 

SELECT s.sid, s.serial#, s.username, s.status, u.tablespace, u.segfile#, u.contents, u.extents, u.blocks
FROM v$session s, v$sort_usage u
WHERE s.saddr=u.session_addr
ORDER BY u.tablespace, u.segfile#, u.segblk#, u.blocks;

==============================================================================================================
check java installed to check ojvm

SELECT version, status FROM dba_registry WHERE comp_id='JAVAVM';


=====================================Oracle HOME backup before patching ==================

How to Perform ORACLE_HOME Backup? (Doc ID 565017.1)

===========================================================================================
Customer RecommendedFAQs on Central Inventory and Oracle Home Inventory (Local Inventory) in Oracle RDBMS (Doc ID 564192.1)	

OraInst.loc
============================
du sort by size 

du -hs * | sort -h
==============================================GOLDEN GATE TRANSACTION====================
archive scn

SQL > set lines 500  pages 300
SQL>  set numformat 9999999999999999999999
SQL > Select first_Scn, STATUS, start_scn, capture_name,REQUIRED_CHECKPOINT_SCN, Applied_scn from dba_capture;

select name, thread#, sequence#, status, first_time, next_time, first_change#, next_change# from v$archived_log  where &SCN between first_change# and next_change#;

How-To Identify a transaction by XID which is provided in the SEND EXTRACT <NAME> SHOWTRANS (Doc ID 1504667.1)

SEND EXTRACT <group>, SKIPTRANS <XID>

====================

show archivelog deletion policy;
Configure RMAN with one of the following options:
CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON ALL STANDBY;

Delete when it has been applied into the Standby.
CONFIGURE ARCHIVELOG DELETION POLICY TO SHIPPED TO ALL STANDBY;

select sequence#,thread#,creator,archived,applied,deleted,status
from v$archived_log where thread#=1;

===================Table reference ==
	 SELECT 
    a.table_name,
    a.constraint_name,
    a.r_constraint_name,
    c.owner AS referenced_table_owner,
    c.table_name AS referenced_table_name
FROM 
    all_constraints a
JOIN 
    all_constraints c ON a.r_constraint_name = c.constraint_name
WHERE 
    a.constraint_type = 'R'
ORDER BY 
    a.table_name;
	
	
	
	
SELECT name, type, referenced_name, referenced_type
FROM all_dependencies
WHERE referenced_name IN (SELECT table_name FROM user_tables);



Step 1: Identify Dependencies
First, identify the tables with primary and foreign key dependencies using the ALL_DEPENDENCIES view.

SELECT name, type, referenced_name, referenced_type
FROM all_dependencies
WHERE referenced_name IN (SELECT table_name FROM list_tables);

Step 2: Group Tables
Group the tables into two sets: those with dependencies and those without.


SELECT 
    a.table_name,
    a.constraint_name,
    a.r_constraint_name,
    c.owner AS referenced_table_owner,
    c.table_name AS referenced_table_name
FROM 
    all_constraints a
JOIN 
    all_constraints c ON a.r_constraint_name = c.constraint_name
WHERE 
    a.constraint_type = 'R'
    and c.table_name='&table'
ORDER BY 
    a.table_name;
	
	
	
	
SELECT 
    a.table_name,
    a.constraint_name,
    a.r_constraint_name,
    c.owner AS referenced_table_owner,
    c.table_name AS referenced_table_name
FROM 
    all_constraints a
JOIN 
    all_constraints c ON a.r_constraint_name = c.constraint_name
WHERE 
    c.table_name='&table' OR a.table_name='&table' 
ORDER BY 
    a.table_name;
	
	
	
	SELECT 
    a.table_name,
    c.owner AS referenced_table_owner,
    c.table_name AS referenced_table_name,
	count(*)
FROM 
    dba_constraints a
JOIN 
    dba_constraints c ON a.r_constraint_name = c.constraint_name
WHERE 
    c.table_name='&table' OR a.table_name='&table' 
group by 
    a.table_name,c.table_name,c.owner
ORDER BY 
    a.table_name;
	
	
	
	In Oracle GoldenGate, we can segregate tables into two different replicates. The first step is to identify the list of tables that have foreign key dependencies. This will help us ensure that all related tables are correctly replicated.

Please find below the steps we will follow:

1. Identify Tables with Foreign Keys: We will compile a list of tables that have foreign key references.
2. Segregate Tables: Based on the dependencies, we will segregate the tables into two separate replicates.
3.Configure GoldenGate: We will configure Oracle GoldenGate to handle the replication of these segregated tables.

If you have any questions or need further clarification, please do not hesitate to reach out.

============================

In Oracle GoldenGate, we can segregate tables into two different replicates. The first step is to identify the list of tables that have primary keys & forign key tables . All these tables should be part of the same replicate to ensure consistency and integrity during the replication process.

TO Identify Tables with Primary Keys tables and forign key tables for this table.

SELECT 
    a.table_name,
    c.owner AS referenced_table_owner,
    c.table_name AS referenced_table_name,
	count(*)
FROM 
    DBA_constraints a
WHERE 
    c.table_name='&table' OR a.table_name='&table' 
group by 
    a.table_name,c.table_name,c.owner
ORDER BY 
    a.table_name;

All above tables should be part of same replicates . 

2. Segregate Tables: Based on the primary key dependencies, we will segregate the tables into two separate replicates.
3. Configure GoldenGate: We will configure Oracle GoldenGate to handle the replication of these segregated tables.
==========================
Manual RAC patching ============
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=209482913259158&parent=EXTERNAL_SEARCH&sourceId=PROBLEM&id=2928238.1&_afrWindowMode=0&_adf.ctrl-state=5zw55al2m_53
Opatchauto Apply, rootcrs.sh -unlock, rootcrs.sh -prepatch failing On CRS (Doc ID 2928238.1)	



During the rebuild process, the index will not be available. The rebuild will generate a significant number of archives and utilize 8 CPUs, which may impact system performance.Once started, the rebuild process cannot be stopped and must continue until completion.Based on our last test in the mirror environment, the rebuild is expected to take approximately 3 hours.

Alter Table Geneva_Admin.COSTEDEVENT add partition P28 values less than (200801000) tablespace COSTEDEVENT_DATA;



ATT.IM.PS.2024 

ACFS and AFD Support On OS Platforms (Certification Matrix). (Doc ID 1369107.1)


=================================
ps aux --sort=-%mem | grep [process_name]
scp -p


Production DBA on call support during weekend 23rd & 24th Nov 2024
=====================Rolling patch in Grid =============
 select sys_context('SYS_CLUSTER_PROPERTIES', 'CLUSTER_STATE') from dual;
 ORA-15137 The ASM cluster is in rolling patch state while Adding New Disk to ASM Storage (Doc ID 3033573.1)
 
 ===================MOVE LOB segmentt ===============
 ALTER SESSION SET SORT_AREA_SIZE=2147483647;
ALTER SESSION FORCE PARALLEL DML;
ALTER SESSION FORCE PARALLEL QUERY;
ALTER TABLE GENEVA_ADMIN.BILLDATA MOVE LOB (DATA) STORE AS (TABLESPACE BILLDATA_DATA2) PARALLEL 8;
select OWNER,TABLE_NAME,COLUMN_NAME,SEGMENT_NAME from dba_lobs where TABLE_NAME='BILLDATA';
================================================= Passworlessssh connectivity =================
1) To configure SSH you need to perform the following steps on each node in the cluster.

$ cd $HOME
$ mkdir .ssh
$ chmod 700 .ssh 
$ cd .ssh
$ ssh-keygen -t rsa

Now accept the default location for the key file Enter and confirm a passphrase. (you can also press enter twice).

2) $ ssh-keygen -t dsa

Now accept the default location for the key file Enter and confirm a passphrase. (you can also press enter twice).


3) $ cat *.pub >> authorized_keys.<nodeX> (nodeX could be the nodename to differentiate files later)


cat *.pub >> authorized_keys.node1
cat *.pub >> authorized_keys.node2

Now do the same steps on the other nodes in the cluster.

When all those steps are done on the other nodes, start to copy the authorized_keys.<nodeX> to all the nodes into $HOME/.ssh/

For example if you have 4 nodes you will have after the copy in the .ssh 4 files with the name authorized_keys.<nodeX>

4) Then on EACH node continue the configuration of SSH by doing the following:


$ cd $HOME/.ssh
$ cat *.node* >> authorized_keys
$ chmod 600 authorized_keys


cat *.atrbadb0* >> authorized_keys
=====================================
if luns of asm disks are extented equally . to perform rebalance . 

alter DISKGROUP DATA resize all;

if luns of asm disks are extented equally . to perform rebalance . ==========================
====================To check row level locks in DB ====
SET LINESIZE 500
SET PAGESIZE 1000
SET VERIFY OFF
COLUMN owner FORMAT A20
COLUMN username FORMAT A20
COLUMN object_owner FORMAT A20
COLUMN object_name FORMAT A30
COLUMN locked_mode FORMAT A15
SELECT   b.session_id AS sid,
       NVL(b.oracle_username, '(oracle)') AS username,
       a.owner AS object_owner,
       a.object_name,
       Decode(b.locked_mode, 0, 'None',
                             1, 'Null (NULL)',
                             2, 'Row-S (SS)
',
                             3, 'Row-X (SX)',
                             4, 'Share (S)',
                             5, 'S/Row-X (SSX)',
                             6, 'Exclusive (X)',
                             b.locked_mode) locked_mode,
       b.os_user_name
FROM   dba_objects a,
       gv$locked_object b
WHERE  a.object_id = b.object_id 
ORDER BY 1, 2, 3, 4;
================================================================================
sql executions ..
SELECT sql_id, plan_hash_value, executions, elapsed_time/1000000 as elapsed_time_secs, (elapsed_time/1000000)/DECODE(executions,0,1,executions) as avg_elapsed_secs, buffer_gets, disk_reads, rows_processed, cpu_time/1000000 as cpu_time_secs FROM v$sql WHERE sql_id = '&sql_id' ORDER BY elapsed_time DESC;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&sql_id', NULL, 'ALLSTATS LAST'));

SELECT plan_hash_value, COUNT(*) executions, AVG(elapsed_time)/1000000 avg_elapsed_secs, MIN(elapsed_time)/1000000 min_elapsed_secs, MAX(elapsed_time)/1000000 max_elapsed_secs, AVG(buffer_gets) avg_buffer_gets, AVG(disk_reads) avg_disk_reads FROM v$sql WHERE sql_id = '&sql_id' GROUP BY plan_hash_value ORDER BY avg_elapsed_secs;

=================	Ansible	==================================
To check Syntax 

ansible-playbook –i web httpd_install.yml –check-syntax

Variables can also be passed during the command line using –e option
================================================================ temp usage by sid ============
col hash_value for a40
col tablespace for a10
col username for a15
set linesize 132 pagesize 1000

SELECT s.sid, s.serial#, s.username, u.tablespace, s.sql_hash_value||'/'||u.sqlhash hash_value, u.segtype, u.contents, u.blocks
FROM v$session s, v$tempseg_usage u
WHERE s.saddr=u.session_addr
order by u.blocks;
============================================================================================

SQL MONITOR

set lines 300 long 1000000 longchunksize 10000000 pages 5000 verify off
select dbms_sqltune.report_sql_monitor('&SQL_ID',type=>'TEXT',report_level=>'ALL') FROM DUAL;

================================================================ Golden gate Start ====

dba_log_groups



======== Golden gate end ==============================


Backup archive log from start of backup to end of backup time . 

#!/bin/bash

# Set environment variables for Oracle
export ORACLE_SID=your_sid_here
export ORACLE_HOME=/path/to/oracle_home
export PATH=$ORACLE_HOME/bin:$PATH
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Log file for RMAN output
LOGFILE="/path/to/logs/archive_backup_${TIMESTAMP}.log"

# Capture current log sequence before backup
START_SEQ=$(rman target / <<EOF | grep "Current log sequence" | awk '{print $NF}'
report archivelog;
exit;
EOF
)

# Full database backup (optional)
rman target / <<EOF >> $LOGFILE
run {
  backup database;
}
exit;
EOF

# Force a log switch to make sure all logs are archived
rman target / <<EOF >> $LOGFILE
sql 'alter system archive log current';
exit;
EOF

# Capture log sequence after backup
END_SEQ=$(rman target / <<EOF | grep "Current log sequence" | awk '{print $NF}'
report archivelog;
exit;
EOF
)

# Backup archive logs between START_SEQ and END_SEQ
rman target / <<EOF >> $LOGFILE
run {
  backup archivelog from sequence $START_SEQ until sequence $END_SEQ delete input;
}
exit;
EOF

echo "Archive log backup completed. Details logged in $LOGFILE."

======================================================================Best query to check degree parallelism for table & index ==========
col table_name format a35
col index_name format a35
Rem Tables that have Indexes with not the same DOP
Rem !!!!! This command can take some time to execute !!!
Rem ---------------------------------------------------;
set lines 150
select substr(t.owner,1,15) Owner ,
t.table_name ,
substr(trim(t.degree),1,7) Degree ,
substr(trim(t.instances),1,9) Instances,
i.index_name ,
substr(trim(i.degree),1,7) Degree ,
substr(trim(i.instances),1,9) Instances
from all_indexes i,
all_tables t
where ( trim(i.degree) != trim(t.degree) or
trim(i.instances) != trim(t.instances) ) and
i.owner = t.owner and
i.table_name = t.table_name;

==========================================================================================================self sid id ===
SELECT sid FROM v$session WHERE audsid = USERENV('SESSIONID') ;

======================
GG commands . 
stats replicates

1. Table is not replicating to Target  .
2. Location of trail files are not correct . 
3. Time sync check point not updated .
     - index do not match between source and Target . 
4. Trail files where corrupted/Delete.


To find current sessions using proxy authentication:

SELECT s.sid, s.serial#, s.username, s.osuser, sci.authentication_type 
FROM v$session s 
JOIN v$session_connect_info sci 
  ON s.sid = sci.sid AND s.serial# = sci.serial# 
WHERE sci.authentication_type = 'PROXY';


5172-5297-9520-0095
exp 10/30


=============  Network IPS ==================


ipcalc -nbmp 10.209.56.123/24

======================================= Memory usage ===
ps aux --sort=-%mem | head

==============================================================

/u01/app/grid/19c/bin/crsctl query crs releasepatch
/u01/app/grid/19c/bin/crsctl query crs softwarepatch
/u01/app/grid/19c/bin/crsctl query crs releaseversion
/u01/app/grid/19c/bin/crsctl query crs softwareversion

/u01/app/grid/19c/bin/crsctl  query crs activeversion -f

=======================Linux os version=======================================
uname -rms
=================================udev stampping=============================================
/sbin/partx -u /dev/sde1
	Command (m for help): n
	Command (m for help): w
	
For Linux 5,6 and 7
# /sbin/partprobe /dev/sde1

# For Linux8
/sbin/partx -u /dev/sde1
 
/usr/lib/udev/scsi_id -g -u -d /dev/sde

[root@oracle-test01 ~]# /usr/lib/udev/scsi_id -g -u -d /dev/sde
1ATA_VBOX_HARDDISK_VB5fc1baee-51bddf0e
[root@oracle-test01 ~]#

ls -ltr /etc/udev/rules.d
vi /etc/udev/rules.d/99-oracle-asmdevices.rules

KERNEL=="sd?1", SUBSYSTEM=="block", PROGRAM=="/usr/lib/udev/scsi_id -g -u -d /dev/$parent", RESULT=="1ATA_VBOX_HARDDISK_VB5fc1baee-51bddf0e", SYMLINK+="oracleasm/ocr-vote-01", OWNER="oracle", GROUP="dba", MODE="0660"

/sbin/udevadm control --reload-rules
/sbin/udevadm trigger

============================Create partitions. =========



FTAB Entries===========
/dev/sdb1 /u01 ext4 defaults 0 0


============== chcek oracle FS ==
df -ha | grep oracle
========================================update gpnp profile manually===========

ProfileSequence="6"


gpnptool edit -net2:net_ada=enp0s8 -p=profile.xml -o=profile.xml -ovr -prf_sq=14

gpnptool sign -p=profile.xml -w=file:/u01/app/19c/grid/gpnp/oracle-01/wallets/peer -o=profile.new

gpnptool put  -p=/u01/app/19c/grid/gpnp/oracle-01/profiles/peer/profile.new

gpnptool rget

=================================================================================